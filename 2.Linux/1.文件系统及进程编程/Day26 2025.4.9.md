 *记录时间：2025年 4月 9日 
 
---

# 2025.4.9 线程笔记

## 线程概述

### 什么是线程？
- **定义**：线程是一个正在运行的程序，是操作系统调度的最小单位。
- **特性**：
  - 线程以独占 CPU 的方式运行。
  - 传统进程可以看作单线程进程，现代进程通常包含多个线程。
- **与进程的关系**：
  - 操作系统以进程为单位分配资源（如内存、文件句柄等）。
  - 线程是进程内的执行单元，依赖进程的资源运行。

### 轻量级线程
- **概念**：轻量级线程（Lightweight Thread）是相对于进程而言的，指线程的创建、销毁和切换开销较小。
- **原因**：线程共享进程的资源（如内存空间），无需为每个线程分配独立的资源。

---

## 多进程与多线程对比

### 多进程的好处
1. **提高吞吐性**：
   - 多进程设计可以并行处理任务，即使是单一应用也能通过多进程提升性能。
   - 例如：Web 服务器通过多进程处理多个客户端请求。
2. **隔离性强**：
   - 进程之间独立运行，一个进程崩溃不会直接影响其他进程。
3. **适用场景**：
   - 适用于需要高隔离性或资源独立的复杂任务。

### 多进程的缺点
1. **进程间通信麻烦**：
   - 需要使用 IPC（Inter-Process Communication）机制，如管道、消息队列或共享内存，复杂度较高。
2. **切换开销大**：
   - 进程切换涉及上下文切换（Context Switch），包括 CPU 寄存器、内存映射表、文件句柄等数据结构的保存和恢复。
   - **上下文定义**：进程运行所需的全部数据结构，包括：
     - CPU 寄存器（如程序计数器 PC、栈指针 SP）。
     - 内存相关信息（如虚拟内存表）。
     - 文件描述符、信号状态等。

### 多线程的优势
- **轻量级**：线程切换仅涉及少量寄存器和栈的保存，开销远小于进程切换。
- **资源共享**：线程共享进程的内存空间（如全局变量、堆），通信更高效。
- **并发性**：多个线程可以并行执行，提升程序的响应速度和吞吐量。

---

## 多线程的内存模型

### 内存共享
- **共享资源**：
  - 线程共享进程的虚拟内存空间，包括：
    - **全局变量**：所有线程可访问。
    - **堆**：动态分配的内存由线程共享。
    - **代码段**：线程执行相同的程序代码。
- **独立资源**：
  - 每个线程拥有独立的栈（局部变量）和寄存器状态。

### /proc 文件系统
- **定义**：`/proc` 是 Linux 中的虚拟文件系统，映射内存数据而非硬盘数据。
- **作用**：提供进程和线程的运行时信息（如内存使用、线程状态）。
- **示例**：`/proc/[pid]/task` 目录下可以看到进程内的所有线程信息。

---

## pthread 库（POSIX 线程库）

### 概述
- **POSIX 标准**：pthread（POSIX Threads）是 POSIX 系统下的线程库，提供用户级线程支持。
- **线程类型**：
  - **用户级线程**：由用户代码在进程内调度，操作系统只感知进程。
  - **内核级线程**：直接由操作系统调度，pthread 默认映射为内核线程。

### 创建线程：pthread_create
- **函数原型**：
  ```c
  int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void*), void *arg);
  ```
- **参数说明**：
  - `thread`：传出参数，用于存储新线程的 ID（主线程可获取子线程 ID）。
  - `attr`：线程属性，填 `NULL` 表示使用默认属性（如栈大小、优先级）。
  - `start_routine`：线程执行的函数指针，参数和返回值均为 `void*`。
  - `arg`：传递给 `start_routine` 的参数。
- **返回值**：
  - 成功返回 0，失败返回错误码。

### 线程的并发性
- **并发特点**：多个线程同时运行，可能并发访问共享资源。
- **竞争条件（Race Condition）**：
  - 当多个线程同时读写全局变量或堆内存时，可能导致数据不一致。
  - **示例**：`perror` 函数依赖全局变量 `errno`，早期多线程访问会导致混乱。

### errno 的演进
- **问题**：最初 `errno` 是全局变量，多线程并发访问会相互覆盖。
- **解决方案**：现代操作系统将 `errno` 改为线程局部变量（Thread-Local Storage, TLS）。
  - 每个线程拥有独立的 `errno` 副本，避免竞争。
  - pthread 库适配了这一改进，但其接口设计已定型。

---

## 多线程共享全局变量

### 竞争条件问题
- **场景**：多线程并发访问共享资源（如全局变量、堆内存）时，未加同步会导致不可预测的结果。
- **示例**：
  ```c
  int counter = 0;
  void* increment(void* arg) {
      for (int i = 0; i < 10000; i++) {
          counter++; // 非原子操作，可能被其他线程干扰
      }
      return NULL;
  }
  ```
  - 两个线程执行 `increment`，最终 `counter` 值可能小于 20000。

### 堆内存共享
- **特点**：堆是进程级的共享资源，所有线程都可以通过 `malloc` 或 `new` 分配和访问。
- **注意**：动态分配的内存需手动同步（如加锁），否则可能引发数据竞争或内存泄漏。

---

## 总结

### 多进程 vs 多线程
- **多进程**：隔离性强，通信复杂，切换开销大，适合独立任务。
- **多线程**：资源共享，通信简单，切换轻量，适合高并发任务。

### 多线程关键点
- **资源分配**：以进程为单位，线程共享进程资源。
- **调度单位**：操作系统以线程为最小调度单位。
- **共享与同步**：线程共享全局变量和堆，需关注竞争条件并使用同步机制（如互斥锁）。

### pthread 使用要点
- 通过 `pthread_create` 创建线程，注意参数传递和线程属性。
- 全局变量访问需警惕竞争，现代系统通过 TLS 优化了部分问题。

---

