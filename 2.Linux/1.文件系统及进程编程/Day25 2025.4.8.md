 *记录时间：2025年 4月 8日 

---

# 2025.4.8

## 一、共享内存

### 1. 管道的问题（性能瓶颈）
- **问题**：
  - 进程数量增加后，管道数量呈平方级增长。
  - 管道通信涉及大量数据拷贝，效率低下。
- **解决方案**：
  - 共享内存是最快的 IPC（进程间通信）方式。

### 2. 共享内存的使用步骤
- **申请共享物理内存**：
  - 通过系统调用（如 `shmget`）向操作系统申请一块共享内存。
- **加载到虚拟内存**：
  - 使用 `shmat` 将共享内存附加到进程的地址空间，进程可像访问普通内存一样操作。
- **访问共享内存**：
  - 通过指针直接读写共享内存。
  - 多进程并发访问需同步控制，避免数据冲突。

### 3. `shmget` - 申请共享内存
- **函数原型**：
  ```c
  int shmget(key_t key, size_t size, int shmflg);
  ```
- **参数**：
  - `key`：
    - `0` 或 `IPC_PRIVATE`：私有共享内存，仅限父子进程访问。
    - 正数：多个进程使用同一 `key` 共享同一块内存。
  - `size`：内存大小，必须是 4096（内存页大小）的整数倍。
  - `shmflg`：
    - `IPC_CREAT`：若内存不存在则创建。
    - `0600`：权限（八进制，用户可读写）。
- **工具**：
  - `ipcs`：查看系统中的共享内存状态。

### 4. `shmat` - 附加共享内存
- **函数原型**：
  ```c
  void *shmat(int shmid, const void *shmaddr, int shmflg);
  ```
- **参数**：
  - `shmid`：`shmget` 返回的共享内存标识符。
  - `shmaddr`：填 `NULL`，由系统自动分配地址。
  - `shmflg`：填 `0`。
- **特点**：
  - 返回 `void*`，类似 `malloc` 和 `mmap`，用于内存操作。
  - `key=0` 时，共享内存仅限父子进程。

### 5. `fork` 与共享内存的关系
- **使用方式**：
  - 先申请共享内存，再 `fork` 创建子进程。
- **问题**：
  - 并发访问共享资源可能导致数据错误。
- **直接原因**：
  - 进程切换时，寄存器与内存数据不一致。

---

## 二、信号

### 1. 信号概述
- **定义**：软件层面的异步事件机制。
- **用途**：常用于进程有序退出并释放资源。
- **产生场景**：
  1. **硬件异步**：如 `Ctrl+C`。
  2. **软件异步**：如 `kill -9`。
  3. **异常指令**：如除零操作。
  4. **软件同步**：进程调用 `abort`。
- **常见信号**：
  - `SIGINT`：`Ctrl+C`，中断进程。
  - `SIGQUIT`：`Ctrl+\`，退出进程。
  - `SIGKILL`：`kill -9`，强制终止。
  - `SIGPIPE`：管道读端关闭，写端继续写。

### 2. `signal` - 注册信号处理
- **函数原型**：
  ```c
  sighandler_t signal(int signum, sighandler_t handler);
  ```
- **类型**：
  - `sighandler_t`：函数指针别名，返回 `void`，参数为 `int`。
- **参数**：
  - `signum`：信号编号。
  - `handler`：回调函数，定义信号发生时的行为。
- **行为**：
  1. `signal` 不会阻塞。
  2. `signal` 不会立即调用 `handler`。
  3. 调用后，每收到指定信号，操作系统调用 `handler`。
  4. 其他信号不受影响。
- **注意**：
  - 信号递送时间过长可能引发问题。

### 3. 信号屏蔽
- **屏蔽字（Mask）**：
  - 位图，记录哪些信号被阻塞。
- **挂起队列（Pending Queue）**：
  - 存储被屏蔽但未递送的信号。
- **递送流程**：
  - 信号产生时，若被屏蔽，进入挂起队列。
  - 屏蔽解除后，操作系统递送队列中的信号。

### 4. `sigset_t` - 信号位图结构
- **操作函数**：
  - `int sigemptyset(sigset_t *set)`：清空信号集。
  - `int sigfillset(sigset_t *set)`：填满信号集。
  - `int sigaddset(sigset_t *set, int signum)`：添加信号。
  - `int sigdelset(sigset_t *set, int signum)`：删除信号。
  - `int sigismember(const sigset_t *set, int signum)`：判断信号是否在集内。
- **使用原则**：
  - 先分配内存（栈/堆/数据段），再取地址。

### 5. `sigpending` - 获取未决信号
- **函数原型**：
  ```c
  int sigpending(sigset_t *set);
  ```
- **用途**：
  - 检查信号（如 2 号信号）是否处于未决状态。

### 6. `sigprocmask` - 修改进程信号屏蔽字
- **函数原型**：
  ```c
  int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
  ```
- **参数**：
  - `how`：
    - `SIG_BLOCK`：阻塞指定信号，原阻塞信号保持。
    - `SIG_UNBLOCK`：解除指定信号的阻塞。
    - `SIG_SETMASK`：设置新的屏蔽字，覆盖原有设置。
  - `set`：目标信号集合。
  - `oldset`：若非 `NULL`，保存调用前的屏蔽字。
- **返回值**：
  - 成功：返回 0。
  - 失败：返回 -1，设置 `errno`。

---

## 三、补充说明
- **信号递送图解**（参考您提供的图片）：
  - 不同信号的处理流程可通过屏蔽字和挂起队列管理。
- **并发控制**：
  - 共享内存和信号都需要同步机制（如锁或信号量）避免冲突。