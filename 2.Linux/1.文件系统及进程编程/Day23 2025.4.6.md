 *记录时间：2025年 4月 6日 9:00*

---

## 进程基础

### 一. 基础知识

#### 1. 意义

操作系统的核心思想是实现任务/程序的**并发执行**，使它们能够**共享 CPU 和其他计算机资源**。为此，操作系统将每个正在执行的程序抽象为一个**进程**。  
- 从程序员的视角来看，每个进程似乎拥有**独立的 CPU 和内存资源**，尽管这种“独占”是虚拟的。  
- 操作系统的职责是**合理调度和分配底层硬件资源**，为进程提供逻辑上的支持。这样，上层程序开发者只需关注进程的独立性，而底层资源的管理则交由操作系统完成。

#### 2. 定义

- **用户角度**：进程是程序的**动态执行过程**，包括从加载到内存、资源分配、运行、调度直到终止的完整生命周期。  
- **操作系统角度**：进程是**资源分配的基本单位**。它不仅需要 CPU 来执行指令，还需要内存等资源来保存运行状态。  

进程包含的资源包括：  
- **代码段**：程序的可执行指令。  
- **数据段**：程序的全局变量和静态变量。  
- **堆**：动态分配的内存。  
- **栈**：函数调用和局部变量的存储空间。  
- 其他资源：打开的文件、挂起的信号、内核数据、内存映射、线程信息（如程序计数器、寄存器状态和栈等）。  

因此，**进程是一个正在运行的程序及其所需资源的集合**。同一个静态程序可以被多次启动，形成多个不同的进程。

#### 3. 状态

进程有以下三种主要状态：  
- **执行态**：进程正在使用 CPU 执行指令。  
- **就绪态**：进程已准备好执行，但正在等待 CPU 资源。  
- **阻塞态**：进程因等待某些事件（如 I/O 操作）而暂停执行。

#### 4. Linux 进程调度

Linux 内核中有一个专门负责调度进程的组件，称为**调度器**。  
Linux 提供**抢占式多任务模式**，允许多个进程分时共享 CPU。以下情况会触发 CPU 抢占：  
1. **时间片用尽**：当前进程的时间片耗尽，调度器切换到其他进程。  
2. **更高优先级的进程就绪**：当一个更高优先级的进程变为可运行状态时，当前进程会被抢占。  
3. **中断和系统调用**：硬件中断或系统调用可能导致进程切换。

##### a. Linux 的调度策略

每个进程都有一个关联的**调度策略**和**调度优先级**。Linux 提供以下主要调度策略：  
1. **完全公平调度器 (CFS)**  
   - 全称：Completely Fair Scheduler  
   - 别名：普通调度策略 (SCHED_NORMAL 或 SCHED_OTHER)  
   - 特点：Linux 的默认调度策略，适用于大多数无特殊要求的任务，力求公平分配 CPU 时间。  

2. **实时调度策略 (Real-time Scheduling Policies)**  
   - 适用于对响应时间有严格要求的任务（如快速响应的实时应用）。  
   - 类型：SCHED_FIFO（先入先出）和 SCHED_RR（轮转调度）。  
   - **注意**：实时调度策略下的进程通常比 CFS 进程具有更高的执行优先级。

---

### 二. 虚拟内存

与虚拟 CPU 类似，每个进程不仅逻辑上独占 CPU，还逻辑上独占一片**连续的内存空间**，即**虚拟内存**。虚拟内存通过内存管理机制为进程提供了隔离和保护。

#### 1. 进程模式

进程分为两种运行模式：  
- **用户态 (User Mode)**  
  1. 执行应用程序代码。  
  2. 无权直接访问硬件资源，必须通过系统调用请求内核服务。  

- **内核态 (Kernel Mode)**  
  1. 执行操作系统内核代码。  
  2. 有权访问所有 CPU 指令和系统内存地址。  
  3. 操作完成后，进程会切换回用户态以确保安全。

#### 2. 用户态空间和内核态空间

- **内存保护机制**：操作系统通过内存保护确保进程只能访问自己的用户态空间，防止进程间数据干扰或直接访问内核空间。  
- **内核态权限**：在内核态，进程可以执行底层操作（如硬件访问）。操作系统通过严格控制进程进入内核态的时机，并在操作完成后返回用户态，防范潜在安全风险。

#### 3. task_struct 结构体

`task_struct` 是 Linux 内核中实现进程控制块 (PCB) 的核心数据结构，包含了进程的几乎所有信息：  
1. **进程状态**：如运行、就绪或阻塞。  
2. **程序计数器**：记录当前指令位置。  
3. **CPU 寄存器**：保存进程的寄存器状态。  
4. **优先级**：调度时的优先级信息。  
5. **信号**：进程接收的信号。  
6. **内存地址**：虚拟内存相关信息。  

通过 `task_struct`，Linux 内核能够追踪所有进程状态，并在调度时进行上下文切换。

---

### 三. Linux 进程相关 Shell 指令

#### 1. ps 命令

`ps` 命令用于查看进程信息，常用选项包括：  
1. **`ps -elf`**  
   - 显示进程的父子关系、优先级、nice 值、线程等待状态等高级信息。  
2. **`ps aux`**  
   - 查看资源占用情况、服务进程、守护进程等。  
3. **`ps aux | grep nginx`**  
   - 筛选特定进程（如 nginx）的详细信息。

#### 2. free 命令

`free` 命令用于查看系统内存占用情况：  
```bash
# 输出示例
Mem:           # 物理内存
  Total:       # 总内存大小
  Used:        # 已使用内存
  Free:        # 未使用内存
  Shared:      # 临时文件存储系统使用的内存
  Buff/Cache:  # 用作缓冲和缓存的内存（加速文件访问）
  Available:   # 系统可用的内存估计值（不影响现有应用）

Swap:          # 交换空间内存
  Total:       # 总交换空间大小
  Used:        # 已使用交换空间
  Free:        # 未使用交换空间

#### 3. top 命令

`top` 命令动态显示系统运行进程信息：  
```bash
# 输出示例
top: 系统概况
  当前时间、系统运行时间、登录用户数、系统负载 (load average: 过去 1、5、15 分钟平均值)
  # 单核 CPU 负载 0～1 正常，超 1 需关注；多核 CPU 负载不超过核心数。

Tasks: 任务情况
  进程总数、运行进程数、睡眠进程数、停止进程数、僵尸进程数

%CPU: CPU 使用情况
  us (user): 用户态 CPU 使用百分比
  sy (system): 内核态 CPU 使用百分比
  ni (nice): 调整优先级的进程 CPU 使用百分比
  id (idle): 空闲 CPU 百分比
  wa (iowait): 等待 I/O 完成的时间百分比
  hi (hardware irq): 硬件中断时间百分比
  si (software irq): 软件中断时间百分比
  st (steal time): 虚拟环境中其他操作系统占用时间百分比

# 第四、五行：等价于 free 命令的内存信息

进程列表：
  PID:     进程唯一标识号
  USER:    运行进程的用户
  PR:      进程优先级
  NI:      nice 值（影响调度优先级）
  VIRT:    虚拟内存总量
  RES:     未换出的物理内存大小
  SHR:     共享内存大小
  S:       进程状态 (R=运行, S=睡眠, Z=僵尸 等)
  %CPU:    CPU 使用百分比
  %MEM:    物理内存使用百分比
  TIME+:   进程累计 CPU 时间
  COMMAND: 启动进程的命令
```

#### 4. kill 命令

`kill` 命令用于向指定进程发送信号：  
```bash
# 显示所有信号
$ kill -l
#通知一下 自己结束进程
$ kill -2 <pid>
# 以异常方式终止进程 (SIGKILL)
$ kill -9 <pid>
```

---

### 四. Linux 进程操作

#### 1. 创建进程

##### a. system 函数

`system` 函数用于执行 Shell 命令，可通过传入命令创建新进程。  
```c
#include <stdlib.h>
int system(const char *command);
```
开销过大 一般不会用
##### b. fork 函数

`fork()` 函数复制当前进程，创建子进程。父子进程完全相同，但身份和 PID 不同。  
```c
#include <unistd.h>
pid_t fork(void);
```
- **返回值**：  
  - 父进程：返回子进程的 PID。  
  - 子进程：返回 0。  
  - 失败：返回 -1。  

###### 内存复制
- **写时复制 (Copy-on-Write)**：  
  1. `fork` 时，父子进程共享物理内存页，标记为只读。  
  2. 当任一进程尝试写入时，操作系统为写入进程分配新内存页。  
  3. 内存会进行复制只在必要的时候 
- 文件对象：父子进程共享读写位置。

##### c. exec 函数族

`exec` 函数族用于在当前进程上下文中加载并运行新程序：  
- **特点**：  
  1. ✅ 保留 PID、父进程 ID、打开的文件描述符等。  
  2. ❌ 替换原有的代码、数据、堆、栈和指令计数器。  
- **常用函数**：  
```c
#include <unistd.h>
int execl(const char *path, const char *arg0, ...);
int execv(const char *path, char *const argv[]);
```
- **示例**：  
```c
// 05_test.c
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[]) {
    int num1 = atoi(argv[1]);
    int num2 = atoi(argv[2]);
    printf("sum: %d\n", num1 + num2);
    return 0;
}
```

#### 2. 退出进程

进程有五种终止方式：  
| **终止方式**         | **类型** |  
|----------------------|----------|  
| `main` 中 `return`   | 正常     |  
| 调用 `exit` 函数     | 正常     |  
| 调用 `_exit`/`_Exit` | 正常     |  
| 调用 `abort` 函数    | 异常     |  
| 接收终止信号         | 异常     |

##### a. exit 族函数

- **`exit(int status)`**  
  - 定义：`<stdlib.h>`  
  - 特点：标准库函数，清理后退出。  
  - 清理工作：  
    1. 调用 `atexit()` 注册的终止处理函数。  
    2. 刷新并关闭所有标准 I/O 流。  
    3. 将控制权交还内核。  
  - 场景：需要保证文件写入完成或收尾工作。  

- **`_exit(int status)`**  
  - 定义：`<unistd.h>`  
  - 特点：系统调用，直接退出，不清理。  
  - 场景：子进程失败时立即终止。  

- **`_Exit(int status)`**  
  - 定义：`<stdlib.h>`  
  - 特点：C99 标准函数，类似 `_exit`，为非 UNIX 系统设计。  

| **函数** | **库**       | **调用终止处理器** | **清理 I/O** | **场景**           |  
|----------|--------------|--------------------|--------------|--------------------|  
| `exit`   | `<stdlib.h>` | ✅                 | ✅           | 正常退出           |  
| `_exit`  | `<unistd.h>` | ❌                 | ❌           | 子进程失败立即退出 |  
| `_Exit`  | `<stdlib.h>` | ❌                 | ❌           | 非 UNIX 立即退出   |  

#### 3. 进程控制

##### a. 孤儿进程

- **定义**：父进程先于子进程退出，子进程成为孤儿进程。  
- **处理**：被 PID 为 1 的进程（通常是 `init` 或 `systemd`）收养，成为其子进程。

##### b. 僵尸进程

- **定义**：子进程先于父进程退出，但父进程未回收其资源，子进程成为僵尸进程 (Zombie Process)。  
- **特点**：  
  1. 保留进程控制块 (PCB)，占用内核资源。  
  2. 未清理的僵尸进程过多可能耗尽系统资源。  
  3. 子进程退出时发送 `SIGCHLD` 信号给父进程。  
  4. 不可运行、不可终止，必须由父进程清理。  

##### c. wait 函数

- **定义**：  
```c
#include <sys/wait.h>
pid_t wait(int *wstatus);
```
- **作用**：  
  1. 等待任意子进程终止。  
  2. 回收子进程资源，防止僵尸进程。  
  3. 返回已结束子进程的 PID。  
- **特点**：阻塞型，若无子进程则返回 -1。  
- **参数**：`wstatus` 保存退出状态，可用宏解析（如 `WIFEXITED`）。  

##### d. waitpid 函数

- **定义**：  
```c
#include <sys/wait.h>
pid_t waitpid(pid_t pid, int *wstatus, int options);
```
- **作用**：等待指定子进程终止并清理。  
- **参数**：  
  - `pid`：  
    - `-1`：任意子进程（等同 `wait`）。  
    - `>0`：指定 PID 的子进程。  
    - `0`：同一进程组的任意子进程。  
    - `<-1`：指定进程组的任意子进程。  
  - `options`：如 `WNOHANG`（非阻塞）。  可以控制等多久
- **返回值**：成功返回子进程 PID，失败返回 -1，非阻塞无子进程退出返回 0。

#### 4. 守护进程

##### a. 定义

**守护进程 (Daemon Process)** 是一种在后台运行的进程，通常：  
- 不依赖终端或用户交互。  
- 系统启动时自动运行，长期驻留后台。  
- 示例：`cron`（定时任务）、`sshd`（远程登录）、`nginx`（Web 服务）、`mysqld`（数据库）。  

##### b. 会话

- **定义**：会话是终端与操作系统之间的一系列交互，用户每次打开终端创建一个新会话。  
- **生命周期**：从登录开始，到注销或终端关闭结束。  
- **结构**：  
  1. 由一个或多个进程组组成。  
  2. 绑定一个控制终端。  
  3. 由控制进程管理。  
- **前台与后台**：  
  - 前台进程组与终端交互。  
  - 后台进程组不直接交互。  
- **信号**：  
  - `Ctrl+C` 发送给前台进程组。  
  - 终端关闭发送 `SIGHUP` 给控制进程。  
- **会话 ID**：  
  - 等于会话领导进程的 PID。  
  - 获取：`pid_t getsid(pid_t pid)`。  
  - 创建：`pid_t setsid(void)`（进程不能是进程组组长）。  

##### c. 守护进程创建流程

1. 父进程创建子进程，父进程退出。  
2. 子进程调用 `setsid()` 创建新会话，脱离终端。  
3. 修改工作目录为根目录（`/`)，避免占用当前目录。  
4. 重设文件权限掩码为 0（`umask(0)`），确保文件创建权限不受限。  
5. 关闭不需要的文件描述符（如 0、1、2）。  

##### d. 日志

守护进程常使用 `syslog` 函数记录日志到系统日志文件（`/var/log/`）：  
```c
#include <syslog.h>
void syslog(int priority, const char *format, ...);
```
- `priority`：日志级别，如 `LOG_ERR`、`LOG_INFO` 等。  
- 示例：  
```c
syslog(LOG_INFO, "Daemon started with PID: %d", getpid());
```

---

