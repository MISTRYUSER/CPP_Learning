*记录时间：2025年 4月 3日 9:00*

---

# 文件流、文件描述符与重定向（2025.4.2）

## 1. 文件流和文件描述符的关系

### 1.1 文件流与文件描述符的联系
- **文件流**：通过 `fopen` 函数创建，返回一个 `FILE *` 指针，用于高级 I/O 操作。
- **文件描述符**：操作系统分配的整数，用于低级 I/O 操作（如 `write`、`read`）。
- **关系**：`fopen` 内部会调用系统函数（如 `open`）获取文件描述符，并将其封装在 `FILE` 结构体中。

#### 示例代码 1：直接使用文件描述符
```c
#include <my_header.h>

int main(int argc, char *argv[]) {
    ARGS_CHECK(argc, 2);
    FILE *fp = fopen(argv[1], "w+");
    ERROR_CHECK(fp, NULL, "fopen");
    ssize_t ret = write(3, "hello", 5); // 假设 3 是文件描述符
    ERROR_CHECK(ret, -1, "write");
    fclose(fp);
    return 0;
}
```
- **问题**：为什么这里直接用 `3` 可能失败？（提示：文件描述符 3 未明确分配）

#### 示例代码 2：使用 `fileno` 获取文件描述符
```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    ARGS_CHECK(argc, 2);
    FILE *fp = fopen(argv[1], "w+");
    ERROR_CHECK(fp, NULL, "fopen");
    int ret = write(fileno(fp), "hello", 5); // 使用 fileno 获取描述符
    ERROR_CHECK(ret, -1, "write");
    fclose(fp);
    return 0;
}
```
- **`fileno`**：从 `FILE *` 中提取文件描述符，桥接高级和低级 I/O。

### 1.2 `FILE` 结构体的内部
`FILE` 是一个结构体，包含文件操作的各种信息，例如：
```c
struct _IO_FILE {
    int _flags;              // 文件状态标志
    char *_IO_write_ptr;     // 当前写入位置指针
    char *_IO_buf_base;      // 缓冲区起始地址
    int _fileno;             // 文件描述符
    // ... 其他字段
};
```
- **直接访问**：可以通过 `fp->_fileno` 获取文件描述符，但更推荐使用 `fileno` 函数。

#### 示例代码 3：直接操作结构体
```c
write(fp->_fileno, "hello", 5);
```

---

## 2. 标准流

### 2.1 标准流的定义
程序启动时，操作系统分配三个标准流：
1. **标准输入（stdin）**：文件描述符 `0`（宏 `STDIN_FILENO`），默认连接键盘。
2. **标准输出（stdout）**：文件描述符 `1`（宏 `STDOUT_FILENO`），默认连接终端。
3. **标准错误（stderr）**：文件描述符 `2`（宏 `STDERR_FILENO`），默认连接终端。

### 2.2 标准流的特点
- 这些流通过 `FILE *` 类型提供（`stdin`、`stdout`、`stderr`），但底层是文件描述符。
- 即使关闭标准流的文件描述符，操作系统会保留其文件对象。

---

## 3. `close` 和重定向的原理

### 3.1 `close` 的作用
- **功能**：关闭一个文件描述符。
- **效果**：只有当文件对象的所有描述符都被关闭时，文件对象才会被释放。
- **标准流例外**：关闭标准流（如 `close(1)`）后，操作系统仍保留其文件对象。

### 3.2 重定向的本质
- **定义**：重定向改变标准流的目标（例如从终端到文件）。
- **机制**：通过修改文件描述符的指向实现。
- **关键点**：重定向只改变缓冲区的目标，不改变进程与标准流缓冲区的连接。

#### 示例说明
- 默认：`stdout`（描述符 1）指向终端。
- 重定向后：`stdout` 指向文件，但缓冲区逻辑不变。

> **重要提示**：实际应用中很少重定向标准输入（`stdin`）。

---

## 4. 使用 `dup` 和 `dup2` 实现重定向

### 4.1 `dup` 函数
- **定义**：
  ```c
  int dup(int oldfd);
  ```
- **功能**：复制文件描述符，返回最小可用新描述符。
- **返回值**：
  1. 成功：新描述符（与 `oldfd` 不同，但指向同一文件对象）。
  2. 失败：返回 -1，设置 `errno`。
- **特点**：新旧描述符共享读写偏移量。

#### 重定向 `stdout` 的步骤
1. 打开文件：
   ```c
   int fd = open("file.txt", O_WRONLY | O_CREAT, 0644); // 假设 fd = 3
   ```
2. 关闭标准输出：
   ```c
   close(1); // 释放描述符 1
   ```
3. 复制描述符：
   ```c
   dup(fd); // 返回 1，指向 file.txt
   ```
4. 结果：`stdout` 输出到文件。

> **问题**：为什么要关闭描述符 1？（提示：确保新描述符占用 1）

### 4.2 `dup2` 函数
- **定义**：
  ```c
  #include <unistd.h>
  int dup2(int oldfd, int newfd);
  ```
- **功能**：将 `oldfd` 复制到 `newfd`，若 `newfd` 已占用则先关闭。
- **返回值**：
  1. 成功：返回 `newfd`。
  2. 失败：返回 -1，设置 `errno`。
- **优势**：无需手动关闭目标描述符。

#### 示例：直接重定向
```c
int fd = open("file.txt", O_WRONLY | O_CREAT, 0644);
dup2(fd, 1); // 1 现在指向 file.txt
close(fd);
```

### 4.3 `dup` 与 `dup2` 的对比
| **特性**           | **dup**                          | **dup2**                          |
|--------------------|----------------------------------|-----------------------------------|
| 作用               | 复制 `oldfd`，返回最小可用描述符 | 复制 `oldfd` 到指定 `newfd`       |
| 是否指定目标描述符 | 否                               | 是                                |
| 是否关闭已有描述符 | 否                               | 是                                |
| 适用场景           | 简单复制                         | 重定向等精确控制                  |

---

## 总结
1. **文件流与描述符**：`fopen` 创建的 `FILE *` 包含文件描述符，可通过 `fileno` 或 `_fileno` 访问。
2. **标准流**：`stdin` (0)、`stdout` (1)、`stderr` (2) 是默认流。
3. **重定向原理**：通过 `close` 和 `dup`/`dup2` 修改描述符指向。
4. **`dup` 和 `dup2`**：`dup` 返回新描述符，`dup2` 指定目标描述符，适合不同场景。

---
