*记录时间：2025年4月 21日*

---
# Epoll 与 IO 多路复用指南

## 一、select 的缺陷

- **位图大小调整不便**：动态调整用于监控文件描述符的位图较为困难。
- **数据拷贝开销大**：用户态与内核态之间存在大量数据拷贝。
- **监听与就绪集合耦合**：监听集合和就绪集合紧密耦合，管理复杂。
- **性能低下**：随着文件描述符数量增加，线性扫描导致性能下降。

## 二、epoll 简介

`epoll` 是一种高效的 IO 多路复用机制，旨在解决 `select` 和 `poll` 的局限性，特别适合处理大量文件描述符。

### 核心特性
- **连接数量无限制**：无硬性限制可监控的文件描述符数量。
- **O(1) 事件触发**：无需全量扫描即可获取就绪事件。
- **状态持久化**：在内核中维护状态，减少开销。
- **触发模式**：支持**边缘触发 (ET)** 和 **水平触发 (LT)**。
- **高性能定时器**：高效的事件通知机制。
- **支持任意文件描述符**：适用于任何文件描述符类型。
- **内核优化**：利用内核级优化提升性能。

### 2.1 底层原理

- **内核数据结构**：`epoll` 的相关数据结构存储在内核态，以文件对象形式存在。
- **分离的集合**：
  - **就绪集合**：存储已准备好进行 IO 操作的文件描述符。
  - **监听集合**：基于**红黑树**实现，用于高效管理被监控的描述符。
- **事件处理**：轮询结束后，将就绪集合从内核态拷贝到用户态，用户可直接遍历就绪集合。

#### 红黑树性质
- 节点为**红色**或**黑色**。
- 根节点为**黑色**。
- 空叶子节点为**黑色**。
- 红色节点的父节点和子节点均为**黑色**。
- 从根到空叶子的所有简单路径包含相同数量的**黑色**节点。

### 2.2 核心函数

#### a. `epoll_create1`
```c
int epoll_create1(int flags);
```
- **作用**：创建 `epoll` 实例，返回其文件描述符。
- **参数**：
  - `flags`：可为 `0` 或 `EPOLL_CLOEXEC`（多线程场景下防止子进程继承描述符）。
- **返回值**：
  - 成功：返回 `epoll` 文件描述符。
  - 失败：返回 `-1`。

#### b. `epoll_ctl`
```c
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```
- **作用**：管理 `epoll` 实例中的文件描述符（添加、修改或删除）。
- **参数**：
  - `epfd`：`epoll` 实例的描述符。
  - `op`：操作类型：
    - `EPOLL_CTL_ADD`：添加新的描述符。
    - `EPOLL_CTL_MOD`：修改已有描述符。
    - `EPOLL_CTL_DEL`：移除描述符。
  - `fd`：目标文件描述符。
  - `event`：指向 `epoll_event` 结构的指针，指定事件类型。
- **返回值**：
  - 成功：返回 `0`。
  - 失败：返回 `-1`。

#### c. `epoll_wait`
```c
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```
- **作用**：等待 `epoll` 实例上的 IO 事件。
- **参数**：
  - `epfd`：`epoll` 实例描述符。
  - `events`：事件数组，用于接收就绪事件（就绪集合）。
  - `maxevents`：`events` 数组的最大容量。
  - `timeout`–
System: 超时时间（毫秒）：
    - `-1`：无限等待。
    - `0`：立即返回。
    - `>0`：等待指定的毫秒数。
- **返回值**：
  - 就绪事件的数量。
  - `0` 表示超时。
  - `-1` 表示错误。

- **轮询后处理**：
  - 用户可访问 `events` 数组（就绪集合）。
  - `events` 数组长度由 `epoll_wait` 的返回值决定。
  - 用户主要通过访问 `events` 中的 `data` 字段，根据不同 `data` 执行相应操作。

#### d. `struct epoll_event`
```c
typedef union epoll_data {
    void        *ptr;
    int          fd;
    uint32_t     u32;
    uint64_t     u64;
} epoll_data_t;

struct epoll_event {
    uint32_t     events;      // 事件类型，如 EPOLLIN, EPOLLOUT 等
    epoll_data_t data;        // 用户数据，可存储 fd 或指针
};
```

| **宏定义**   | **含义**                   |
|--------------|----------------------------|
| `EPOLLIN`    | 可读事件                   |
| `EPOLLOUT`   | 可写事件                   |
| `EPOLLRDHUP` | 对端关闭连接               |
| `EPOLLPRI`   | 紧急数据可读               |
| `EPOLLERR`   | 错误事件                   |
| `EPOLLHUP`   | 挂起事件                   |
| `EPOLLET`    | 边缘触发（默认水平触发）   |
| `EPOLLONESHOT` | 一次性事件               |

- **常见用法**：`data` 字段通常存储文件描述符 (`fd`)。

#### e. 使用流程
1. 创建 `epoll` 实例（`epoll_create1`）。
2. 注册需要监听的文件描述符（`epoll_ctl`）。
3. 等待事件发生（`epoll_wait`，主事件循环）。
4. 处理就绪事件。

## 三、基于 epoll 实现双人聊天（支持断线重连）

- **客户端**：继续使用 `select` 实现。
- **服务端**：
  - **单人模式**：仅监听 `sockfd`（用于接受新连接）。
  - **双人模式**：同时监听 `netfd`（客户端连接描述符）和 `stdin`（标准输入）。

## 四、基于 epoll 实现聊天室

- **持续监听 `sockfd`**：处理新客户端的接入。
- **每次 `accept`**：生成一个新的 `netfd`，并将其加入 `epoll` 监听集合。

## 五、读取磁盘文件 vs 读取设备/管道/套接字

```c
while(1) {
    ret = read(fd, buf, len);
    if (ret == xxx) { break; }
}
```

- **读取磁盘文件**：上述循环有效，因为磁盘文件通常有明确的结束条件（如文件末尾）。
- **读取管道/设备/套接字**：上述循环可能无效，因为这些描述符可能长时间无数据或无明确结束条件。
- **结论**：
  - 在不确定退出条件的循环中，`read` 必须是非阻塞的。
  - 使用 `fcntl` 将文件描述符设置为非阻塞：
    ```c
    fcntl(fd, F_SETFL, O_NONBLOCK);
    ```

## 六、5 种 IO 模型（参考《UNIX 网络编程》）

### 1. 同步阻塞模型
```c
while(1) {
    read(fd1); do_sth1();
    read(fd2); do_sth2();
    read(fd3); do_sth3();
}
```
- **流程**：
  - 用户线程调用 `read`，进入内核态。
  - 内核检查数据是否就绪，若未就绪，线程阻塞。
  - 数据就绪后，内核唤醒线程，数据返回用户态。
- **特点**：线程在数据未就绪时阻塞，效率较低。

### 2. 同步非阻塞模型
```c
while(1) {
    if (read_nonblock(fd1)) { do_sth1(); }
    if (read_nonblock(fd2)) { do_sth2(); }
    if (read_nonblock(fd3)) { do_sth3(); }
}
```
- **特点**：`read` 不阻塞，立即返回状态，需轮询检查，CPU 开销较高。

### 3. 同步 IO 多路复用
```c
register(fd1, fd2, fd3);
while(1) {
    select/epoll_wait();
    if (fd1_ready) { do_sth1(); }
    if (fd2_ready) { do_sth2(); }
    if (fd3_ready) { do_sth3(); }
}
```
- **特点**：通过 `select` 或 `epoll` 监控多个描述符，减少无效轮询，提升效率。

### 4. 异步模型
```c
void callback1() { /* 处理 fd1 数据 */ }
void callback2() { /* 处理 fd2 数据 */ }
void callback3() { /* 处理 fd3 数据 */ }

void func() {
    aio_read(fd1, callback1); // 通知 OS 数据就绪时调用 callback1
    aio_read(fd2, callback2);
    aio_read(fd3, callback3);
    do_other_thing();
}
```
- **特点**：用户注册回调函数，数据就绪时由内核调用回调，线程无需等待。

### 5. 信号驱动 IO 模型
- **特点**：通过信号通知用户线程数据就绪，较少使用。

## 七、epoll 就绪触发条件

- **默认触发模式**：`epoll_wait` 使用**水平触发 (LT)**。
- **水平触发 (Level-Triggered)**：
  - 只要描述符状态满足条件（如有数据可读），`epoll_wait` 持续返回。
  - 适合单线程处理，易于管理。
- **边缘触发 (Edge-Triggered)**：
  - 仅在描述符状态发生变化时（如从无数据到有数据）触发一次。
  - 需确保一次性处理完所有数据，否则可能遗漏。

#### 设置边缘触发
```c
event.events = EPOLLIN | EPOLLET;
```

- **边缘触发注意事项**：
  - 可能导致数据残留，需多次调用 `recv` 确保数据读完：
    ```c
    while (recv(fd, buf, len, 0) > 0) { /* 处理数据 */ }
    ```
  - `recv` 必须是非阻塞的。

#### 水平触发 vs 边缘触发
- **水平触发**：适合 `epoll_wait` 和事件处理在同一线程。
- **边缘触发**：
  - 适合 `epoll_wait` 和事件处理在不同线程。
  - 旧版本内核可能仅支持边缘触发。

## 八、服务端框架

服务端软件需同时管理多个客户端连接。

### 最简单方案：多线程/多进程模型
```c
while(1) {
    netfd = accept();
    pthread_create/fork(handle_client, netfd);
}
```
- **优势**：
  - 线程/进程隔离，单个阻塞不影响其他连接。
  - 代码实现简单。
- **缺陷**：
  - 每个连接分配一个线程/进程，难以支持高并发。
  - 线程/进程过多导致上下文切换开销大（C10K 问题）。
  - 调度策略调整需深入内核，复杂。

## 九、事件驱动模型

```c
while(1) {
    epoll_wait();
    handle_events();
}
```
- **优势**：
  - 一个连接对应一个文件描述符，支持高并发。
  - 单线程运行，无上下文切换开销。
  - 调度逻辑由用户代码控制，灵活性高。
- **架构**：
  ```
  [客户端] → [Reactor: epoll_wait()] → [Handler: 读/写/关闭]
  ```
- **典型实现**：Nginx 使用事件驱动模型，基于 `epoll` 实现高性能。

---

