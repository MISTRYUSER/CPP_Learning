登录的时候
客户端发出 HTTP 请求 -》GateServer 进行验证-》status 状态端进行分配 ChatServer->返回 Tcp 连接信息

聊天：
客户端发送信息—>ChatServer 进行转发->StatusServer确认接收方状态->在线转发/离线缓存
如何实现高并发 后端采用 Boost.Asio异步 I/O 和多线程 IOContext 池处理请求采用分布式架构通过负载均衡分散压力 单节点支持8000+连接
利用 asio 的多线程模式 根据 cpu 的核数分装 IOContext 连接池 每个连接池跑在单独线程采用异步读和异步写的方式 采用了 proactor 模式
proactor 就是指的是 IO 异步可以分散压力
每个连接通过 Session 类管理，通过智能指针管理 Session 
客户端和服务器端通信采用 json 通过 TLV 方式分装信息
即信息 id+信息长度+信息内容防止粘包 通过心跳机制检测连接可用性
保证服务高效可用
1.采用故障检测和自动恢复
2.采用分布式架构
将应用拆分为多个独立的服务，降低单个服务故障对整体系统的影响
3.进行数据备份和恢复
4.多活部署
在不同的地理位置和设备上部署多个活跃的数据中心
为什么要封装 Mysql 连接池
多个线程连接同一个 Mysql 是不安全的要为每个线程单独分配独立连接，
压力测试
测试一定连接数下收发效率稳定性
采用 pingpong 协议 手法效率稳定在 10ms 以下 连接数上限
保证 10ms 延迟的情况下 在 8000-2w 连接
-线程池通过单例封装 内部初始化 N 个线程 采用生产者消费者方式管理线程包括任务队列 通过对外接口提交任务
通过有限状态机对输入关键字进行匹配匹配成功之后 交给 trie 字典后缀树进行查找 trie 树的查找效率远远大于哈希表 但是问题就是 trie 所用的空间大于哈希表
token