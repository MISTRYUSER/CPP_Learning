
*记录时间：2025 年 3 月 13日*

---

# 2025.3.13 学习笔记


## 1. 位运算符

### 移位运算符
移位运算符操作数的二进制表示：
- **左移（`<<`）**：低位补 0，相当于乘以 2 的幂。
- **右移（`>>`）**：对于有符号数，高位补符号位（正数补 0，负数补 1）；无符号数补 0。

```c
int num = 40;    // 二进制: 0010 1000
num = num << 2;  // 左移两位: 1010 0000，结果为 160
num = num >> 1;  // 右移一位: 0101 0000，结果为 80
```

### 按位操作
按位操作逐位处理：
- **`&`（按位与）**：常用于掩码操作。
- **`|`（按位或）**：常用于置位。
- **`^`（按位异或）**：可用于交换两数（不推荐）。
- **`~`（按位取反）**：翻转所有位。
- **`!`（逻辑非）**：非 0 变 0，0 变 1。

```c
int num1 = 30;    // 二进制: 0001 1110
int num2 = 35;    // 二进制: 0010 0011
int and_result = num1 & num2;  // 0000 0010 (2)
int or_result = num1 | num2;   // 0011 1111 (63)
int xor_result = num1 ^ num2;  // 0011 1101 (61)
int not_result = ~num1;        // 1110 0001 (-31，补码表示)
```

#### 面试题：LSB（最低有效位）
获取最低有效位 1 的值：
```c
int find_last_set_bit(int n) {
    return n & (-n);  // 返回最低位 1 对应的值
}
```
**示例**：
- `n = 40 (0010 1000)`，`-n = -40 (1101 1000)`，`n & (-n) = 0000 1000 (8)`。

---

## 2. 数组

### 随机访问
数组支持 O(1) 时间访问：
- **原理**：内存连续，地址计算公式为 `base_addr + index * sizeof(type)`。
- **示例**：
```c
char ch_arr[7] = {'a', 'b', 'c', 'd', 'e', 'f', 'g'};
printf("%c\n", ch_arr[2]);  // 输出 'c'
```

### 数据结构的逻辑与物理结构
1. **逻辑结构**：
   - 线性表：数组、链表。
   - 非线性：树、图。
2. **物理结构**：
   - **数组**：连续存储，适合查询。
   - **链表**：分散存储，适合动态调整。

---

## 3. 数组操作

### 定义与初始化
- **长度**：必须是编译期常量。
- **初始化方式**：
```c
int arr[5] = {1, 2, 3, 4, 5};  // 完整初始化
int arr2[] = {1, 2, 3};         // 自动推断长度为 3
int arr3[5] = {1, 2};           // 部分初始化，后补 0
int arr4[5] = {0};              // 全 0 初始化
```

### 遍历
使用 `sizeof` 计算长度：
```c
int arr[] = {10, 20, 30, 40, 50};
int len = sizeof(arr) / sizeof(arr[0]);
for (int i = 0; i < len; i++) {
    printf("%5d", arr[i]);  // 右对齐输出
}
```

---

## 4. 二维数组
内存连续，逻辑上为“行×列”：
```c
int arr2[2][3] = {{1, 2, 3}, {4, 5, 6}};
printf("%d\n", arr2[1][1]);  // 输出 5
```

---

## 5. `const`
`const` 仅限制直接修改：
```c
const int num = 10;
// num = 20;         // 错误：直接赋值被禁止
int* p = (int*)&num;
*p = 20;             // 可通过指针修改
printf("%d\n", num); // 输出 20
```

---

## 6. 随机发牌程序（优化版）

### 需求
- 去掉大小王，52 张牌（4 种花色 × 13 种点数）。
- 用户输入发牌数量，输出不重复的手牌。

### 实现思路
1. 用数组记录已发牌，避免重复。
2. 用随机数生成花色和点数。
3. 检查重复并重新生成。

### 代码
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    // 定义花色和点数
    char suit_arr[4] = {'c', 'd', 'h', 's'};  // 梅花、方块、红心、黑桃
    char point_arr[13] = {'2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'};
    
    int num_cards;
    printf("请输入发牌数量（1-52）: ");
    scanf("%d", &num_cards);
    
    // 输入校验
    if (num_cards <= 0 || num_cards > 52) {
        printf("无效数量！请输入 1-52 之间的数字。\n");
        return 1;
    }
    
    // 初始化牌状态数组，0 表示未发，1 表示已发
    int used[52] = {0};  // 52 张牌的标记
    srand(time(NULL));   // 设置随机种子
    
    printf("你的手牌:\n");
    for (int i = 0; i < num_cards; i++) {
        int card_index;
        do {
            card_index = rand() % 52;  // 随机生成 0-51 的索引
        } while (used[card_index]);    // 如果已发，重新生成
        
        used[card_index] = 1;          // 标记为已发
        int suit = card_index / 13;    // 计算花色
        int point = card_index % 13;   // 计算点数
        printf("%c%c ", suit_arr[suit], point_arr[point]);
    }
    printf("\n");
    
    return 0;
}
```

### 优化说明
1. **去重逻辑**：用 `used` 数组记录每张牌的状态，`card_index` 映射到 52 张牌。
2. **映射方式**：
   - 花色：`card_index / 13`（每 13 张换花色）。
   - 点数：`card_index % 13`。
3. **性能**：对于小数量发牌，效率足够；若发牌数接近 52，需优化随机生成逻辑（如洗牌算法）。

---

## 总结
- 位运算：底层优化利器，需理解二进制。
- 数组：基础数据结构，掌握随机访问和操作。
- 发牌程序：结合随机数和数组，实践逻辑思维。
