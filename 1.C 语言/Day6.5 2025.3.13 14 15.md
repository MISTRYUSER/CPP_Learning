### 三天学习笔记总结（2025.3.13 - 2025.3.15）

#### 记录时间
- **2025 年 3 月 13 日 - 2025 年 3 月 15 日**  
- 总结时间：**2025 年 3 月 15 日（当前日期）**

---

### 一、核心内容概览

#### 1. 位运算符（2025.3.13）
- **移位运算符**：
  - 左移（`<<`）：低位补 0，乘以 2 的幂。
  - 右移（`>>`）：有符号数补符号位，无符号数补 0。
- **按位操作**：
  - `&`（与）、`|`（或）、`^`（异或）、`~`（取反）、`!`（逻辑非）。
  - 应用：掩码、置位、交换数值、翻转位。
- **面试题**：获取最低有效位 1 的值（`n & (-n)`），如 `40 & (-40) = 8`。

#### 2. 数组（2025.3.13）
- **特点**：
  - 随机访问 O(1)，内存连续。
  - 逻辑结构（线性表）与物理结构（连续存储）的结合。
- **操作**：
  - 定义与初始化：固定长度、部分初始化补 0。
  - 遍历：用 `sizeof` 计算长度。
- **二维数组**：逻辑上行×列，内存仍连续。
- **实践**：优化版随机发牌程序，结合数组与随机数实现去重逻辑。

#### 3. 函数（2025.3.14）
- **基本概念**：
  - C 语言为面向过程，函数是模块化核心。
  - 定义格式：返回值类型、函数名、形参列表、函数体。
- **分类**：标准库函数与自定义函数。
- **设计原则**：单一性、高效性。
- **变量类型**：
  - 局部变量：作用域和生命周期受限于栈帧。
  - 全局变量：程序生命周期，建议少用。
  - 静态局部变量：只初始化一次，保留值。
- **调用与栈**：后进先出，支持递归，栈帧管理局部变量。
- **递归**：需出口避免栈溢出，适合分解问题（如汉诺塔）。

#### 4. 指针（2025.3.15）
- **前置知识**：
  - 内存地址：唯一标识，32 位/64 位系统决定寻址范围。
  - 指针变量：存储地址，`*` 解引用取值。
  - 野指针（未初始化）与空指针（`NULL`）的区别。
- **数组与指针**：
  - 数组名通常为首元素指针，特例为 `sizeof` 和 `&arr`。
  - 数组指针（`int (*p)[n]`）与指针数组（`int *p[n]`）。
- **高级内容**：
  - `const` 指针：限制修改值或指向。
  - 二级指针（`int **pp`）：修改指针的指向。
  - 函数指针（`int (*f)(int, int)`）：指向函数。

---

### 二、知识点提炼

#### 1. 基础技能
- **位运算**：掌握二进制操作，优化底层代码。
- **数组**：理解内存布局，熟练操作和遍历。
- **函数**：模块化设计，变量作用域与生命周期管理。
- **指针**：内存地址操作，区分值传递与地址传递。

#### 2. 实践能力
- **发牌程序**：综合运用数组、随机数和去重逻辑，体现了算法思维。
- **函数设计**：如三角形面积计算，注重输入校验和单一职责。
- **递归应用**：汉诺塔问题展示了递归分解复杂问题的能力。

#### 3. 面试加分
- **位运算技巧**：最低有效位提取。
- **指针高级用法**：`const` 指针、二级指针、函数指针。
- **栈与内存**：理解函数调用栈的 LIFO 特性及其硬件支持。

---

### 三、总结与建议

#### 学习成果
- **三天内容层层递进**：
  - 从底层位运算到数据结构（数组），再到程序模块化（函数）和内存操作（指针）。
  - 理论与实践结合，代码示例丰富，逻辑清晰。
- **重点掌握**：
  - 位运算的二进制思维。
  - 数组的内存连续性与随机访问。
  - 函数的单一性与栈管理。
  - 指针的地址操作与高级应用。
---

### 四、关键代码片段

#### 1. 位运算 - LSB
```c
int find_last_set_bit(int n) {
    return n & (-n);  // 获取最低有效位 1
}
```

#### 2. 数组 - 发牌程序
```c
int used[52] = {0};
for (int i = 0; i < num_cards; i++) {
    int card_index;
    do {
        card_index = rand() % 52;
    } while (used[card_index]);
    used[card_index] = 1;
    printf("%c%c ", suit_arr[card_index / 13], point_arr[card_index % 13]);
}
```

#### 3. 函数 - 汉诺塔
```c
void hanoi_print(int n, char start, char sup, char target) {
    if (n == 1) {
        printf("%c --> %c\n", start, target);
        return;
    }
    hanoi_print(n - 1, start, target, sup);
    printf("%c --> %c\n", start, target);
    hanoi_print(n - 1, sup, start, target);
}
```

#### 4. 指针 - 二级指针
```c
int a = 10, b = 20;
int *p = &a;
int **pp = &p;
*pp = &b;  // p 指向 b
```

---
