*记录时间：2025 年 3 月 15日*

---

# 指针 

## 1. 前置知识点

### a. 内存地址的概念
- **定义**: 内存地址是内存中某个位置的唯一标识，就像房子的门牌号。
- **比喻**: 可以把内存想象成一个大数组，地址就像数组的下标，每个位置存着一个值。
- **位数相关**: 地址的大小与程序的位数相关：
  - 32 位系统 (x86): 地址用 32 个二进制位表示，能寻址 2³² = 4GB 内存。
  - 64 位系统: 地址用 64 位表示，寻址范围非常大。
- **示例代码**:
  ```c
  #include <stdio.h>
  int main() {
      char ch = 'b';
      printf("ch 的内存地址: %p\n", (void*)&ch);  // 输出地址，如 0x7fff5fbffabc
      return 0;
  }
  ```
  - `&ch`: 取 `ch` 的地址。
  - `%p`: 用于打印地址，需将指针转为 `(void*)`。

### b. 指针与指针变量
- **指针**: 就是内存地址，表示某个数据在内存中的位置。
- **指针变量**: 用来存储地址的变量。
- **示例代码**:
  ```c
  #include <stdio.h>
  int main() {
      char ch = 'c';
      char *p_ch = &ch;  // p_ch 是一个指针变量，存 ch 的地址
      int num = 123456;
      int *p_num = &num; // p_num 存 num 的地址
      printf("ch 的值: %c\n", *p_ch);  // 输出 c
      printf("num 的值: %d\n", *p_num); // 输出 123456
      return 0;
  }
  ```
  - `*p_ch`: 解引用，取出地址指向的值。
  - 指针变量本身也占用内存，有自己的地址。

### c. 指针的声明
- **推荐写法**: `int *p;`（`*` 紧跟类型，清晰表明 `p` 是指针）。
- **不推荐**: `int* p;`（容易误解 `*` 属于变量名）。
- **建议**: 
  - 每行只声明一个变量。
  - 如果多个变量类型一致且作用相似，可以放一行，如 `int *p1, *p2;`。
- **初始化方式**:
  1. **用变量地址**:
     ```c
     int num = 10;
     int *p_num = &num;
     ```
  2. **用 NULL**:
     ```c
     int *p = NULL;  // 表示不指向任何有效地址
     ```
  3. **用其他指针赋值**:
     ```c
     int *p1 = &num;
     int *p2 = p1;  // p1 和 p2 指向同一地址
     ```

### d. 野指针与空指针
- **野指针**:
  - 未初始化或指向未知内存的指针。
  - **危害**: 可能导致程序随机崩溃或行为异常。
  - **示例**:
    ```c
    int *p1;           // 野指针，未初始化
    int *p3 = (int*)10086; // 野指针，指向非法地址
    // printf("%d\n", *p1); // 未定义行为，可能崩溃
    ```
- **空指针**:
  - 指向地址 0 的指针，用 `NULL` 表示。
  - **特点**: 不能解引用（`*p` 会崩溃），用于标记指针未使用。
  - **示例**:
    ```c
    int *p2 = NULL;
    // *p2 = 10; // 崩溃，空指针不能赋值
    ```
- **调试建议**: 程序崩溃时，用调试器（如 gdb）定位问题行。

### e. 值传递与指针
- **值传递**: 函数调用时，实参的值复制给形参，修改形参不影响实参。
- **指针的作用**: 通过传递地址，可以间接修改原始数据。
- **示例代码**:
  ```c
  #include <stdio.h>
  void test1(int num) {
      num = 777;  // 只改副本
      printf("test1 内: %d\n", num);
  }
  void test2(int *num) {
      *num = 888;  // 通过指针修改原始值
  }
  int main() {
      int num = 444;
      test1(num);
      printf("test1 后: %d\n", num);  // 444，未变
      test2(&num);
      printf("test2 后: %d\n", num);  // 888，改变了
      return 0;
  }
  ```
  - 值传递复制的是值，指针传递复制的是地址，通过 `*` 修改地址指向的内容。

---

## 2. 数组名与指针

### a. 数组名是啥？
- **大多数情况**: 数组名（如 `arr`）是一个指针，指向数组第一个元素（`&arr[0]`）。
- **特例**:
  1. `sizeof(arr)`: 返回整个数组的大小（字节数）。
  2. `&arr`: 返回数组的地址，是数组指针类型（如 `int (*)[n]`）。

### b. 代码示例
```c
#include <stdio.h>
void test1() {
    int arr[5] = {10, 20, 30, 40, 50};
    int *p = arr;  // p 指向 arr[0]
    printf("p[0]: %d\n", *p);      // 10
    printf("p[1]: %d\n", *(p + 1)); // 20，指针运算
    printf("sizeof(arr): %zu\n", sizeof(arr)); // 20 (5 个 int)
    printf("sizeof(p): %zu\n", sizeof(p));     // 4 或 8 (指针大小)
}
void test2() {
    int arr[5] = {10, 20, 30, 40, 50};
    int (*p_arr)[5] = &arr;  // 数组指针
    printf("(*p_arr)[0]: %d\n", (*p_arr)[0]); // 10
}
int main() {
    test1();
    test2();
    return 0;
}
```

### c. 数组名当作指针时的特点
- **算术运算**: `arr + 1` 移动一个元素大小。
- **赋值**: 可以赋给指针变量。
- **函数传参**: 自动退化为首元素指针。

---

## 3. 数组指针与指针数组

### a. 数组指针
- **定义**: 指向整个数组的指针，类型为 `int (*p)[n]`。
- **用途**: 操作二维数组或传递整个数组。
- **示例**:
  ```c
  int arr[4] = {1, 2, 3, 4};
  int (*p_arr)[4] = &arr;
  printf("%d\n", (*p_arr)[2]); // 3
  ```

### b. 指针数组
- **定义**: 一个数组，元素是指针，类型为 `int *p[n]`。
- **用途**: 管理多个分散变量的地址。
- **示例**:
  ```c
  int a = 10, b = 20, c = 30;
  int *p_int[3] = {&a, &b, &c};
  printf("%d\n", *p_int[0]); // 10
  ```

### c. 完整示例
```c
#include <stdio.h>
void test1() {
    int arr[5] = {1, 2, 3, 4, 5};
    int *p_arr[5] = {arr, arr + 1, arr + 2, arr + 3, arr + 4}; // 指针数组
    int (*p_arr2)[5] = &arr;  // 数组指针
    printf("指针数组: %d\n", *p_arr[1]);  // 2
    printf("数组指针: %d\n", (*p_arr2)[1]); // 2
}
void test2() {
    int a = 10, b = 20, c = 30, d = 40, e = 50;
    int *p_int[5] = {&a, &b, &c, &d, &e};
    for (int i = 0; i < 5; i++) {
        printf("%d\n", *p_int[i]); // 10, 20, 30, 40, 50
    }
}
int main() {
    test1();
    test2();
    return 0;
}
```

---

## 4. 面试加分点

### a. const 指针
- `const int *p`: 不能修改指向的值，但可以改指向。
- `int *const p`: 不能改指向，但可以改值。
- `const int *const p`: 两者都不能改。

### b. 二级指针
- **定义**: 指向指针的指针，如 `int **pp`。
- **用途**: 修改指针的指向。
- **示例**:
  ```c
  int a = 10, b = 20;
  int *p = &a;
  int **pp = &p;
  *pp = &b;  // p 现在指向 b
  printf("%d\n", *p); // 20
  ```

### c. 函数指针
- **定义**: 指向函数的指针，如 `int (*f)(int, int)`。
- **示例**:
  ```c
  int add(int a, int b) { return a + b; }
  int (*f)(int, int) = add;
  printf("%d\n", f(2, 3)); // 5
  ```
