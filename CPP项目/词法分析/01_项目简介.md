###### <sub><font color = orange>王道C++班级参考资料</font></sub><br />——<br />C语言部分<sup><font color=white>卷8</font></sup>词法分析器项目<br/><sup><sub><font color=cyan>节1</font></sub><font color=cyan>项目简介</font></sup><br/><br/>*最新版本`V2.0`*<br>**王道C++团队**<br/>*COPYRIGHT ⓒ 2021-2024. 王道版权所有*

[TOC]

# 概述和目的

> _~Gn!~_
>
> 这个项目是用C语言编写一个功能完备的C语言词法分析器。目的是为了锻炼大家的C语言能力、基本的数据结构与算法能力，以及加深大家对C语言的认识。
>
> 词法分析器只是编译器编译处理代码的第一步，是最前置的部分，难度不会很大，但代码逻辑会很琐碎。大家要仔细理解分析，才能够比较好的完成。
>
> 在VS当中查看代码，鼠标光标相关的移动快捷键：
>
> 1. 点击CTRL + 左键，可以进入查看函数
> 2. 看完了以后想回到调用的位置用快捷键：
>    1. **后退："Ctrl" 加上 "-"**
>    2. **前进："Ctrl" 加上 "Shift" 加上 "-"**

# 编译器的处理流程

> _~Gn!~_
>
> 软件设计的架构中，我们之前讲过一种分层架构，比如Java应用和操作系统之间的JVM，Java虚拟机
>
> ![分层架构](https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202401160810679.png#padding#400w)
>
> 除了这种分层架构，还有一种非常常见的架构形式：流水线架构
>
> <span style=color:red;background:yellow>**各个阶段的职责，简单描述如下：**</span>
>
> 1. 词法分析：对源文件进行扫描，将源文件的字符划分为一个一个的记号(token) (注：类似中文中的分词)。 
>
> 2. 语法分析：根据语法规则将 Token 序列构造为语法树。
>
> 3. 对语法树的各个结点之间的关系进行检查，检查语义规则是否有被违背，同时对语法树进行必要的优化，此为语义分析。
>
> 4. 遍历语法树的结点，将各结点转化为中间代码，并按特定的顺序拼装起来，此为中间代码生成。
>
> 5. 对中间代码进行优化
>
> 6. 将中间代码转化为目标代码
>
> 7. 对目标代码进行优化，生成最终的目标程序
>
> 以上阶段的划分仅仅是逻辑上的划分。实际的编译器中，常常会将几个阶段组合在一起，甚至还可以能省略其中某些阶段。
>
> 编译器的设计就是非常典型的流水线架构
>
> ![编译器的流水线](https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202401160821647.png#padding#600w)
>
> AST：<span style=color:red;background:yellow>**abstract syntax(语法) tree**</span> 语法分析只是简单的对语法做分析处理，比如判断if/for的结构对不对，语句写得对不对，但不会结合上下文判断语法。比如break加分号就是一条合法的语句，它就能通过语法分析，但break语句并不是什么位置都能放，还要结合上下文判断它放置的位置对不对。
>
> 结合上下文对语法进行分析判断，这个过程就是语义分析。
>
> 语法和语义分析结束后，就意味着源代码是符合语言语法设计的，此时它会生成一棵优化后AST
>
> 这些过程可能会根据不同的编译器实现，过程会有不同的取舍，但总体是这样的。
>
> 语义分析结束后，某些编译器还会先生成中间代码，C/C++没有这样的过程，比较典型的就是Java的字节码文件（javac编译器）
>
> 中间代码往往是平台无关的二进制指令，这样就实现了跨平台性（Java就是利用.class文件，加上JVM实现了优良的跨平台性）
>
> 接下来的工作就是一整套各种优化，中间代码优化，平台无关优化，平台相关优化...
>
> 编译器的前端往往是需要手动实现的，如果你想写一个编译器的话，你的主要工作就是编写基于你的编程语言的编译器前端。后端部分在大多情况下则不需要自己编写，有一个非常成熟好用的现成的LLVM编译器后端，可以直接套用（RUST就直接使用这个编译器后端）
>
> LLVM是一个类似GNU的开源项目，主要的产品是LLVM编译器后端以及Clang(编译器前端，一个C/C++等语言的编译器套件)
>
> ![image-20240116125303480](https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202401161253573.png#padding#600w)

## 词法分析阶段做什么？

> _~Gn!~_
>
> 编译器扫描源文件的字符流，过滤掉字符流中的空格、注释等，并将其划分为一个个的 token，生成 token 序列。
>
> 例如下面的语句：
>
> ```
> a = value + sum(5, 123); 
> ```
>
> 将被拆分为11个 token ：
>
> ```
> a           标识符
> =           赋值运算符
> value       标识符
> +           加号
> sum         标识符
> (           左括号
> 5           整数
> ,           逗号
> 123         整数
> )           右括号
> ;           分号
> ```
>
> 这个步骤和中文的语句分词非常类型。
>
> ```
> 我/喜欢/美丽动人的/茜茜/。  
> ```
>
> 本质上，词法分析阶段所做的事情就是模式匹配。判断哪些字符属于标识符，哪些字符属于关键字，哪些字符属于整数...
>
> 词法分析，通过将源代码转换为标准化的Token流，使得编译器能够更高效地处理和分析程序代码。
>
> > **有限状态机的概念**
> >
> > 词法分析阶段所做的事情就是模式匹配，读到一串字符序列就判断匹配一下它属于标识符，还是关键字，亦或者是个整数常量...
> >
> > 具体这个过程咋做呢？
> >
> > 此时常规的做法就是用<font color=red>**有限状态机(Finite state machine，简称FSM)**</font>，这是编译原理当中的一个概念，但你不要被术语给吓住了。我们今天也无意给大家讲编译原理
> >
> > 所以我们就用尽量通俗的语言讲一下什么叫有限状态机
> >
> > 现在假设，让你自己去阅读一段源代码，当你读到一个字符开头时，你会根据这个字符是字母、数字还是其他符号来决定它可能是什么类型的词汇。比如，当你看到一个字母时，你可能会想：“这可能是一个关键字/标识符的开始。” 当你继续读下去，看到更多的字母，你就更确定这是一个标识符了。如果突然出现了一个数字，你可能会想：“哦，这应该不是关键字，而是标识符。” 这个过程就是你在使用你的大脑来“解析”源代码。进行词法分析。
> >
> > 而有限状态机的原理和这是类似的。
> >
> > 在词法分析中，有限状态机的工作方式类似于上述过程：
> >
> > 1. **开始**：就像你开始阅读文本一样，FSM从一个起始点开始。它准备好接收字符，并根据这些字符来决定下一步做什么。
> > 2. **读取字符**：FSM会读取源代码中的字符。每次它读取一个字符，它都会根据当前的“理解”和这个新字符来决定下一步做什么。
> > 3. **状态变化**：这就像你在阅读时的思考过程。比如，FSM可能开始时处于“我在寻找一个关键字”的状态。当它读到一个字母时，它可能转变到“我正在读一个关键字”的状态。但如果它读到一个数字，它可能会转变到“这可能是一个关键字了而是一个包含数字的标识符”的状态。
> > 4. **完成识别**：当FSM根据读到的字符序列有了足够的信息时，就像你最终理解了一个单词是什么意思一样，FSM会说：“好的，我知道这是什么了！” 然后它会输出这个词汇的种类(Token)，比如“这是一个数字”或“这是一个标识符”。
> > 5. **重复**：之后，FSM就会准备好读取下一个词汇，就像你继续阅读下一个单词一样。
> >
> > 这就是有限状态机在词法分析中的基本工作原理。它通过读取字符并根据这些字符来“决定”自己的状态，直到能够识别出完整的词汇为止。
> >
> > 举几个例子：
> >
> > <span style=color:red;background:yellow>**例子 1：固定单字符Token**</span>
> >
> > 比如：: ; ) ( { } 
> >
> > 单字符Token识别特别简单，只要读取到该字符，直接生成Token完成识别
> >
> > 单字符Token可以直接被识别的特性，使得它非常合适使用switch选择语句来识别处理。
> >
> > <span style=color:red;background:yellow>**例子 2：双字符Token**</span>
> >
> > **例子**：识别不等于 `!=`。
> >
> > 1. **读取第一个字符**：读取到字符 `!`。
> > 2. **状态转换**：读到了!表示它可能是单子符Token ! 亦或者是双字符Token !=
> > 3. **继续读取第二个字符**：读取到字符 `=`。
> > 4. **状态转换**：FSM识别出这是一个 双字符`!=` Token，转换到完成识别状态
> > 5. **识别完成**：输出双字符Token，不等于 `!=`。
> >
> > 这个过程就是switch先判断第一个字符，然后再用if...else if ... else判断后续字符的过程，只需要在碰到第一个字符后，"喵"一眼后面的字符，if...else判断一下就可以搞清楚它是单字符还是双字符
> >
> > <span style=color:red;background:yellow>**例子 3：多字符Token**</span>
> >
> > 这个过程无非就是要用 while 语句一直读取到结束标志符
> >
> > 比如字符串字面值："abcd"，只要读到双引号的左边，就需要用while循环一直读到右边，就确定中间是一个字符串字面值。
> >
> > 再比如识别一个标识符"my_variable"，由于标识符的开头不能是数字
> >
> > 所以如果读到一个数字123，那么就会进入数字状态，不会进入标识符识别状态。这也是标识符普遍不能用数字开头的原因
> >
> > **例子**：识别标识符，比如 `my_variable`。
> >
> > 1. **读取字符**：读取到字母 `m`。
> > 2. **状态转换**：FSM转移到一个中间状态，表示它正在读取一个可能的标识符。
> > 3. **继续读取字符**：继续读取字符 `y_variable`，FSM保持在读取标识符的状态。
> > 4. **结束标识符**：遇到空格、换行或其他非字母数字字符时，FSM完成对标识符的读取。
> > 5. **识别完成**：输出多字符Token，标识符 `my_variable`。
> > 6. **Token识别**：输出多字符Token `my_variable`。

## 实现效果

> _~Gn!~_
>
> 该应用要可以实现交互式的运行，可以直接处理用户输入的"源代码(片段)"
>
> 比如：
>
> ![实现效果-图1](https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202401161304331.png#padding#400w)
>
> 也可以处理一个".c"源文件，此时需要传入一个源文件的路径。对 'main.c' 文件进行词法分析：
>
> ```c
> // main.c
> int main(void) {
>        printf("Hello world\n");
>        return 0;
> }
> ```
>
> 效果如下：
>
> ![实现效果-图2](https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202401161305558.png#padding#400w)

# 代码框架

> _~Gn!~_
>
> 代码的基准框架已经搭建完毕了，大家只需要进行填空实现其中的核心需求就可以了。
>
> 毕竟如果从头开始写的话，实现的难度是非常大的，大家可以也会觉得无从下手。所以框架我已经给你们搭建完成了，而且我还给出一些一些实现的示例，你可以模仿我给的示例，继续去写实现就可以了。
>
> 大家以后工作接触到项目的时候，项目也肯定不太可能就是从0开始的，就是会有一个骨架，有一些已实现的功能，然后你们进行缝缝补补，增加删除维护一些代码即可。
>
> 这个过程如果有详细的描述文档当然是最好的，但国内公司的情况，普遍是没有的。或者只有一些简陋的文档
>
> 所以看代码，根据代码框架搞清楚代码的作用，并且要知道接下来你要做什么，要怎么做，是一项很重要的能力。
>
> 我给出的代码框架注释是比较详尽的，实际工作中可能这些都是没有的，需要你自己去认真分析。
>
> 当然我们刚刚学习编程，欠缺这种能力也很正常，现在我们还有很多时间来加强这一方面的能力。

## 头文件

> _~Gn!~_
>
> 对于C语言来说，我们看一个项目，最好先看头文件，因为头文件中包含一些重要的类型定义，函数原型等（头文件类似接口，高级语言中我们往往也会先看接口）
>
> 头文件我已经完全设计好了，你不需要改动了，如下：
>
> ```` c
> #ifndef SCANNER_H
> #define SCANNER_H
> 
> // 定义一个TokenType枚举，用于标记不同种类的Token
> typedef enum {
>     /* 单字符 Token */
>     TOKEN_LEFT_PAREN,        // '(' 左小括号
>     TOKEN_RIGHT_PAREN,       // ')' 右小括号
>     TOKEN_LEFT_BRACKET,      // '[' 左中括号
>     TOKEN_RIGHT_BRACKET,     // ']' 右中括号
>     TOKEN_LEFT_BRACE,        // '{' 左大括号
>     TOKEN_RIGHT_BRACE,       // '}' 右大括号
>     TOKEN_COMMA,             // ',' 逗号
>     TOKEN_DOT,               // '.' 点
>     TOKEN_SEMICOLON,         // ';' 分号
>     TOKEN_TILDE,             // '~' 波浪号
> 
>     /* 可能是单字符或双字符的Token */
>     TOKEN_PLUS,                  // '+' 加号
>     TOKEN_PLUS_PLUS,             // '++' 自增运算符
>     TOKEN_PLUS_EQUAL,            // '+=' 加赋运算符
>     TOKEN_MINUS,                 // '-' 减号或负号
>     TOKEN_MINUS_MINUS,           // '--' 自减运算符
>     TOKEN_MINUS_EQUAL,           // '-=' 减赋运算符
>     TOKEN_MINUS_GREATER,         // '->' 结构体指针访问
>     TOKEN_STAR,                  // '*' 乘号
>     TOKEN_STAR_EQUAL,            // '*=' 乘赋运算符
>     TOKEN_SLASH,                 // '/' 除号
>     TOKEN_SLASH_EQUAL,           // '/=' 除赋运算符
>     TOKEN_PERCENT,               // '%' 取模运算符
>     TOKEN_PERCENT_EQUAL,         // '%=' 取模赋运算符
>     TOKEN_AMPER,                 // '&' 按位与运算符
>     TOKEN_AMPER_EQUAL,           // '&=' 按位与赋运算符
>     TOKEN_AMPER_AMPER,           // '&&' 逻辑与运算符
>     TOKEN_PIPE,                  // '|' 按位或运算符
>     TOKEN_PIPE_EQUAL,            // '|=' 按位或赋运算符
>     TOKEN_PIPE_PIPE,             // '||' 逻辑或运算符
>     TOKEN_HAT,                   // '^' 按位异或运算符
>     TOKEN_HAT_EQUAL,             // '^=' 按位异或赋运算符
>     TOKEN_EQUAL,                 // '=' 赋值运算符
>     TOKEN_EQUAL_EQUAL,           // '==' 等于比较运算符
>     TOKEN_BANG,                  // '!' 逻辑非运算符
>     TOKEN_BANG_EQUAL,            // '!=' 不等于比较运算符
>     TOKEN_LESS,                  // '<' 小于比较运算符
>     TOKEN_LESS_EQUAL,            // '<=' 小于等于比较运算符
>     TOKEN_LESS_LESS,             // '<<' 左移运算符
>     TOKEN_GREATER,               // '>' 大于比较运算符
>     TOKEN_GREATER_EQUAL,         // '>=' 大于等于比较运算符
>     TOKEN_GREATER_GREATER,       // '>>' 右移运算符
> 
> 
>     /*
>         所有的三字符Token都去掉了, 比如:">>= <<="等
>         实现它们也没什么特殊的，但会很无聊繁琐，所以就都去掉了
>         以下是多字符的Token: 标识符、字符、字符串、数字
>     */
>     TOKEN_IDENTIFIER,            // 标识符
>     TOKEN_CHARACTER,             // 字符
>     TOKEN_STRING,                // 字符串
>     TOKEN_NUMBER,                // 数字，包含整数和浮点数
> 
>     /* 关键字Token 涉及C99所有关键字 */
>     TOKEN_SIGNED, TOKEN_UNSIGNED,
>     TOKEN_CHAR, TOKEN_SHORT, TOKEN_INT, TOKEN_LONG,
>     TOKEN_FLOAT, TOKEN_DOUBLE,
>     TOKEN_STRUCT, TOKEN_UNION, TOKEN_ENUM, TOKEN_VOID,
>     TOKEN_IF, TOKEN_ELSE, TOKEN_SWITCH, TOKEN_CASE, TOKEN_DEFAULT,
>     TOKEN_WHILE, TOKEN_DO, TOKEN_FOR,
>     TOKEN_BREAK, TOKEN_CONTINUE, TOKEN_RETURN, TOKEN_GOTO,
>     TOKEN_CONST, TOKEN_SIZEOF, TOKEN_TYPEDEF,
> 
>     // 注意：#define #include这样的预处理指令 不是关键字
>     // 辅助Token
>     // 词法分析阶段也是可以检测出一些错误的 比如$只能在字符和字符串中 比如字符串"acb 缺少右边双引号
>     // 词法分析阶段不进行错误处理，只是将错误的Token信息抛出，以待后续统一进行处理
>     // 流水线架构每个阶段都可能出错，如果每个阶段都进行错误处理，那代码的可维护性就太差了
>     TOKEN_ERROR,                 // 错误Token 词法分析时遇到无法识别的文本
>     TOKEN_EOF                    // 文件结束Token 表示源代码已经分析完毕
> } TokenType;
> 
> // 词法分析器的目的就是生产一个一个的Token对象 
> typedef struct {
>     TokenType type;		// Token的类型, 取任一枚举值
>     // Token的起始字符指针
>     const char *start;	// start指向source中的字符，source为读入的源代码。
>     int length;		    // length表示这个Token的长度
>     int line;		    // line表示这个Token在源代码的哪一行, 方便后面的报错和描述Token
> } Token;	// 这个Token只涉及一个字符指针指向源代码的字符信息,没有在内部保存字符数据
> 
> // 对 词法分析器Scanner 进行初始化 
> void initScanner(const char *source);	// 源代码字符串(这里涉及一个将源码转换成字符串的函数)
> // 核心API, 调用scanToken(), 就生产一个Token, 也就是源代码中下一段字符数据的Token
> Token scanToken();	// 当Token返回的是TOKEN_EOF时，源文件被消耗完毕，词法分析结束
> 
> #endif  // !SCANNER_H
> ````
>
> 所以了解这些以后，我们就发现 Scanner词法分析器的机制就如下：
>
> ![image-20240422083756342](https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/image-20240422083756342.png#padding#600w)

## main.c单元测试

> _~Gn!~_
>
> 看完原型头文件后，我们就来看单元测试代码，也就是main.c文件。看代码切记不要按照顺序从上到下看，而是先找到主函数，再跳来跳去的看。
>
> 从main函数开始看，因为它是程序的入口。
>
> main函数的形参不是void，说明允许传入命令行参数，当然也可以处理命令行参数。
>
> 看函数的顺序：
>
> <span style=color:red;background:yellow>**main函数 --> repl函数 --> main函数 --> runFile函数(直接给同学们写出出实现) --> readFile函数(实现) --> run函数(分析处理源文件字符数据,核心逻辑)**</span>
>
> ```` c
> #define _CRT_SECURE_NO_WARNINGS
> #include <stdio.h>
> #include <stdlib.h>
> 
> #include "scanner.h"
> #include "tools.h"
> 
> // main.c中的核心逻辑
> static void run(const char *source) {
> 	// 初始化词法分析器, 准备对输入的源代码进行词法分析。
> 	initScanner(source);
> 	// 用于记录当前处理的代码行号, -1表示还未开始处理
> 	int line = -1;
> 	for (;;) {  // 死循环
> 		Token token = scanToken();  // 获取下一个TOKEN
> 		// 此TOKEN的行数和之前的TOKEN行数不同,也就是读到代码换行了
> 		// 于是打印效果要更改一下,每一行代码中的第一个TOKEN打印效果就是先打印行数
> 		if (token.line != line) {
> 			printf("%4d ", token.line); // %4d 会打印4个宽度的整数,不够会在前面补空格,这是为了格式美观
> 			line = token.line;  // 更新line
> 		}
> 		else {
> 			// 如果TOKEN是同一行代码中的,就打印竖线(替代了line),这同样是为了美观
> 			printf("   | ");
> 		}
> 
> 		/*
> 		* 注意前面始终都没有换行,所以下面的内容还是在同一行
> 		* 这里一共有74个不同的枚举值,所以用%2d打印是足够的
> 		*
> 		* 不能用%s,因为它会打印整个字符串,也就是碰到空字符才结束打印
> 		* 而整个代码字符串都只有末尾存在一个空字符,显然不合理
> 		* 为什么是%.*s
> 		* 首先"."在这里和"%.2f"当中的"."意思是一样的,浮点数表示小数点后面的保留位数
> 		* 在非浮点数的情况下,其实表示的是打印的宽度
> 		* 如果这里写"%.10s" 就表示打印10个长度的字符串
> 		* 但这里长度很明显不能在编译时期确定 必须运行时期确定
> 		* 于是就用".*s" 其中"*"表示的含义是从函数后面的传参中读取长度
> 		*
> 		* 所以整体的打印效果是打印从 token.start 开始、长度为 token.length 的字符串。
> 		* token.start表示这个TOKEN在源代码中的起始位置
> 		*/
> 		char *str = convert_to_str(token);
> 		printf("%s '%.*s'\n", str, token.length, token.start);
> 
> 		if (token.type == TOKEN_EOF) break;     // 读到TOKEN_EOF结束循环
> 	}
> }
> // repl是"read evaluate print loop"的缩写
> // repl 函数定义了一个交互式的读取-求值-打印循环（REPL）逻辑
> // 它允许用户输入源代码行，逐行进行词法分析，并打印分析结果
> // 也就是说启动时没有主动给出一个命令行参数表示文件路径的话,那么就进行交互式界面进行词法分析
> static void repl() {
> 	/*
> 	* 这个过程无非就是从键盘录入接收一整行的数据
> 	* 而且应该是一个死循环接收键盘录入
> 	* 只有确定读到了末尾没有下一行了, 才会停止接收录入
> 	* 所以这里应该用fgets函数（不能用fget因为它不安全）
> 	* repl函数最终要调用run函数
> 	*/
> 	char line[1024];
> 	for (;;) {
> 		printf("> ");
> 		if (fgets(line, sizeof(line), stdin) == NULL) {
> 			printf("\n");
> 			break;
> 		}
> 		run(line);
> 	}
> }
> static char *readFile(const char *path) {
> 	// 用户输入文件名，将整个文件的内容读入内存，并在末尾添加'\0'
> 	// 注意: 这里应该使用动态内存分配，因此应该事先确定文件的大小。
> 	// 打开文件
> 	FILE *file = fopen(path, "rb");
> 	if (file == NULL) {
> 		fprintf(stderr, "Could not open file \"%s\".\n", path);
> 		exit(1);
> 	}
> 	// 获取文件大小并倒带
> 	fseek(file, 0L, SEEK_END);
> 	size_t fileSize = ftell(file);
> 	rewind(file);
> 	// 动态内存分配字符数组,长度是文件大小 + 1
> 	char *buffer = (char *)malloc(fileSize + 1);
> 	if (buffer == NULL) {
> 		fprintf(stderr, "Not enough memory to read \"%s\".\n", path);
> 		exit(1);
> 	}
> 	// 利用fread函数一次性将file_size大小的数据读到字符数组中
> 	size_t bytesRead = fread(buffer, sizeof(char), fileSize, file);
> 	if (bytesRead < fileSize) {
> 		fprintf(stderr, "Could not read file \"%s\".\n", path);
> 		exit(1);
> 	}
> 	// 不要忘记末尾加空字符
> 	buffer[bytesRead] = '\0';
> 	// 关闭流
> 	fclose(file);
> 	return buffer;
> }
> 
> // 该函数表示对传入的文件路径名的字符串进行处理
> static void runFile(const char *path) {
> 	// 处理'.c'文件:用户输入文件名，分析整个文件，并将结果输出
> 	// 这个代码非常简单，我帮你直接写好
> 	// 会调用上面的readFile函数，根据文件路径名生成一个包含文件全部字符信息的字符串
> 	char *source = readFile(path);
> 
> 	// 调用run函数处理源文件生成的字符串
> 	run(source);
> 	// 及时释放资源
> 	free(source);
> 	// 下面我们先看一下readFile函数的实现
> }
> 
> /*
> * 主函数支持操作系统传递命令行参数
> * 然后通过判断参数的个数:
> * 1.如果没有主动传入参数(argc=1),因为第一个参数总会传入一个当前可执行文件的目录作为命令行参数
> * 此时执行repl函数
> * 2.如果传递了一个参数(argc=2),说明传递了一个参数,将传递的参数视为某个源代码的路径
> * 然后调用runFile函数,传入该源代码文件的路径,处理源文件
> */
> int main(int argc, const char *argv[]) {
> 	if (argc == 1) {
> 		repl();
> 	}
> 	else if (argc == 2) {
> 		runFile(argv[1]);
> 	}
> 	else {
> 		// 如果主动传入超过一个命令行参数.即参数传递有误,错误处理
> 		// 告诉用户正确的使用函数的方式
> 		fprintf(stderr, "Usage: scanner [path]\n");
> 		exit(1);
> 	}
> 	return 0;
> }
> ````

## 实现词法分析器

> _~Gn!~_
>
> 下面就是我们的重头戏——实现词法分析器。
>
> 原则上来说, 在.c中实现.h文件, 只需要实现两个函数就可以了。但实际上这个实现并不是简简单单就写两个函数就完成了。
>
> .c的实现文件怎么看呢？首先关注的核心点肯定是两个头文件中的函数的实现，但实际上.c文件中多了很多内容，我们先来看看Scanner这个结构体类型。
>
> 这个Scanner就是我们的词法分析器本身。这里有个小问题：
>
> 为什么Scanner这个结构体类型定义没有放入.h文件中呢？思考这个问题的答案，其实就是要想明白.h头文件当中需要放什么？
>
> 头文件的作用实际类似高级语言中的接口，用于存放需要对外暴露，公共的部分，比如Token、TokenType以及两个函数肯定是需要被外界访问的，也完全可能在词法分析的下一个阶段被用到，这样它们就必须写在头文件中。但像Scanner这个类型定义，只会在词法分析阶段有用，外界包括下一个阶段的流程也不需要知道具体是谁做了这个事情，只需要知道这个事情做好了就可以了。比如你买了个新手机，反正你付钱手机给你就可以了，你也不会纠结究竟你的手机是谁设计的，谁造出来的。
>
> 这就是一种信息隐藏技术，也就是封装，封装的越好，别人用起来就越方便简单，所以这种设计很常见。等到了C++阶段，封装就是面向对象的重要特性之一，是面向对象的基础。
>
> 讲解的顺序是：
>
> ![image-20240422091607721](https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/image-20240422091607721.png#padding#600w)
>
> <span style=color:red;background:yellow>**Scanner结构体 --> initScanner(并实现) --> （辅助函数，逐个注释） --> （另一个核心函数scanToken）--> **</span>
>
> <span style=color:red;background:yellow>**skipWhitespace(解释)--> identifier()函数先跳过不看 --> number()函数 --> **</span>
>
> <span style=color:red;background:yellow>**再看scanToken中的switch语句 --> 单字符Token --> 双字符Token --> string和character函数简单讲一下 -->**</span>
>
> <span style=color:red;background:yellow>**最后讲 identifier()函数**</span>

## 各个符号处理的方式

> _~Gn!~_
>
> <font color=red>**为了让大家更好的实现词法分析过程，这里给定对每种符号的处理方式，基本上都模仿借鉴了C语言的语法，部分实现进行了简化，你可以直接按照这里给出的处理方式进行操作。当然如果你愿意，也可以对处理方式做出你想要的修改。**</font>
>
> <span style=color:red;background:yellow>**标识符：**</span>
>
> 以英文字母或下划线为开头，整体允许包含字母，数字，下划线，不考虑其余类型字符。
>
> <span style=color:red;background:yellow>**数字：**</span>
>
> 整数和浮点数直接合并成处理数字，数字可以以任何数字开头，可能包含一个小数点来表示浮点数，但小数点不能在数字中间，也就说小数点的前后都要有数字。
>
> 举例：1.1、0.1、00001、123等都是合法的，能正常处理成一个数字
>
> 但".1"会处理成运算符点和整数1两个Token，同理"11."也会被处理成两个Token
>
> <span style=color:red;background:yellow>**字符串：**</span>
>
> 字符串必须以双引号 `" "` 开始和结束，字符串内可以包含任何字符，但不能包含双引号和换行符（不支持多行字符串），也不支持使用\\表示的转义字符。
>
> 比如"123"、"abc"这样就是合法的，但"、"""等都不正确。
>
> <span style=color:red;background:yellow>**字符：**</span>
>
> 字符字面量由单引号 `' '` 开始和结束，且只包含一个字符，如 `'a'` 或 `'1'`。不支持多行字符，也不支持\\表示的转义字符。
>
> 比如'a'、'b'等这样的都可以，不支持'abc'、'\\123'这样的字符。
>
> <span style=color:red;background:yellow>**注释：**</span>
>
> 只支持单行注释，不支持多行注释，而且注释不分析Token类型，而是直接跳过一整行单行注释

## 参考实现代码

> _~Gn!~_
>
> ```` c
> #define _CRT_SECURE_NO_WARNINGS
> 
> #include <stdbool.h>
> #include <string.h>
> #include <stdio.h>
> 
> #include "scanner.h"
> 
> /*
> 	该结构体是不需要放入头文件中的
> 	因为它属于词法分析阶段实现原理的一部分,是不需要暴露给外界看的
> 	对内隐藏实现细节
> 	对外提供必要的接口
> 	这就是封装,在生活和编程当中,封装的例子都随处可见
> 	词法分析器的结构体类型(实现词法分析过程需要Scanner对象来参与完成)
> */
> typedef struct {
>     // start一开始应该指向源代码字符串的起始位置
>     // 当开始扫描一个新的Token时，这个指针指向Token的第一个字符。
>     const char *start;
>     // 词法分析器当前正在扫描处理的字符,会从某个Token的开头字符开始,一直移到Token结束,指向此Token的下一个字符
>     const char *current;
>     // 当前读取的行
>     int line;
> } Scanner;
> 
> // 全局变量结构体对象,后续所有函数的操作都基于同一个scanner结构体对象
> static Scanner scanner;
> static char message[50];		// 该全局变量字符数组用于存储打印errToken时,存放错误信息
> 
> void initScanner(const char *source) {
>     // 初始化全局变量scanner
>     // start和current一开始都可以指向源代码字符串的起始位置
>     scanner.start = source;
>     scanner.current = source;
>     scanner.line = 1;
> }
> 
> // 下面我给大家提供了很多会用到的辅助函数,建议使用
> // 检查字符c是否是字母或下划线。
> static bool isAlpha(char c) {
>     return (c >= 'a' && c <= 'z') ||
>         (c >= 'A' && c <= 'Z') ||
>         c == '_';
> }
> 
> // 检查字符c是否是数字。
> static bool isDigit(char c) {
>     return c >= '0' && c <= '9';
> }
> 
> // 判断词法分析器当前正在处理的字符是不是空字符(即判断是否处理完了)，curr不动
> static bool isAtEnd() {
>     return *scanner.current == '\0';
> }
> 
> // curr指针前进一个字符,并返回之前curr指针指向的元素
> static char advance() {
>     return *scanner.current++;
> }
> 
> // 查看当前正在处理的字符是什么,curr不动
> static char peek() {
>     return *scanner.current;
> }
> 
> // 如果当前正在处理的字符不是空字符,那就返回下一个要处理的字符,但curr不动
> static char peekNext() {
>     if (isAtEnd()) {
>         // 如果已经在处理空字符了，那么直接返回空字符
>         return '\0';
>     }
>     return *(scanner.current + 1);
> }
> 
> // 检查词法分析器当前正在处理的字符是不是符合预期,如果符合预期,curr前进一位
> static bool match(char expected) {
>     if (isAtEnd()) {
>         // 如果已经在处理空字符了，那么直接返回false
>         return false;
>     }
>     if (peek() != expected) {
>         // 如果当前处理的字符不符合预期，直接返回false
>         return false;
>     }
>     scanner.current++;  // 在返回true之前, 将curr向后移动一位
>     return true;
> }
> 
> // 根据传入的TokenType类型来制造返回一个Token
> static Token makeToken(TokenType type) {
>     Token token;
>     token.type = type;
>     token.start = scanner.start;    // scanner.start是当前Token的第一个字符
>     // 当此Token结束时,也就是处理它最后一个字符时,curr指向该Token后的第一个字符,此时指针相减就是Token的字符串长度
>     token.length = (int)(scanner.current - scanner.start);
>     token.line = scanner.line;  // 更新line行
>     return token;
> }
> 
> // 当遇到不可识别的字符时,就返回一个TOKEN_ERROR类型的Token
> // 比如遇到@，$等不在处理范围内的符号时，比如处理字符串，字符没有对应的右引号时。
> static Token errorToken(const char *message) {
>     Token token;
>     token.type = TOKEN_ERROR;
>     token.start = message;
>     token.length = (int)strlen(message);
>     token.line = scanner.line;
>     return token;
> }
> 
> static void skipWhitespace() {
>     // 跳过空白字符: ' ', '\r', '\t', '\n'和注释
>     // 注释以'//'开头, 一直到行尾
>     // 注意更新scanner.line！
>     /*
> 	* 思路:
> 	* 不知道究竟有多少个 所以要死循环
> 	* 瞥一眼下一个字符然后switch判断
> 	* 碰到空格,制表,回车就advance前进..
> 	* 如果碰到换行 那就sc.line++再前进
> 	* 注释:
> 	* 如果下一个字符是/,那就再瞥一眼下下个字符,如果还是/,那就是注释
> 	* 此时要把一整行都要跳过,用while循环
> 	* 结束:
> 	* 只要不是下一个字符不是上面提出来的几个,就结束死循环
> 	*/
>     for (;;) {
>         char c = peek();
>         switch (c) {
>             case ' ':
>             case '\r':
>             case '\t':
>                 advance();
>                 break;
>             case '\n':
>                 scanner.line++;
>                 advance();
>                 break;
>             case '/':
>                 if (peekNext() == '/') {
>                     // 跳过一整行注释
>                     while (!isAtEnd() && peek() != '\n') advance();
>                 }
>                 else {
>                     return;
>                 }
>                 break;
>             default:
>                 return;
>         }
>     }
> }
> // 用于检查当前扫描的Token的类型是不是type 如果是就返回type
> static TokenType checkKeyword(int start, int length, const char *rest, TokenType type) {
>     /*
> 		start: 待检查序列的起始字符下标
> 			比如要检查关键字break，那么在case b的前提下，需要传入reak来进行检查
> 			这里start就等于1，scanner.start[1]
> 		length: 待检查序列的长度，如果检查的是break，就是检查剩余的reak
> 			需要传入4
> 		rest指针，待检查的剩余序列字符串，这里直接传入一个字面值字符串就行了
> 			比如检查break，传入"reak"就好了
> 		type：你要检查的关键字Token的类型，比如检查break，那就传入Token_BREAK
> 
> 		检查从start位置开始，长度为length的字符串是否与给定的rest字符串相匹配
> 		先判断长度是否一致 再判断内容
> 	*/
>     if (scanner.current - scanner.start == start + length &&
>         /*
> 					int memcmp(const void *s1, const void *s2, size_t n);
> 					这里的参数分别是：
> 
> 					s1：指向第一块内存区域的指针。
> 					s2：指向第二块内存区域的指针。
> 					n：要比较的字节数。
> 					memcmp 函数会逐字节比较 s1 和 s2 指向的内存区域，直到有不相等的字节或比较了 n 个字节为止。
> 					如果两个内存区域完全相同，
> 					则 memcmp 返回 0；如果第一个不同的字节在 s1 中的值小于 s2 中对应的值，返回负数；
> 					反之，返回正数。
> 		*/
>         memcmp(scanner.start + start, rest, length) == 0) {
>         return type;
>     }
>     return TOKEN_IDENTIFIER;
> }
> 
> static TokenType identifierType() {
>     // 确定identifier类型主要有两种方式：
>     // 1. 将所有的关键字放入哈希表中，然后查表确认 
>     // Key-Value 就是"关键字-TokenType" 可以做 但存在额外内存占用且效率不如下一个方式好
>     // 2. 将所有的关键字放入Trie树(读踹，字典查找树)中，然后查表确认
>     // Trie树的方式不管是空间上还是时间上都优于哈希表的方式
>     char c = scanner.start[0];
>     // 用switch...switch...if组合构建逻辑上的trie树
>     switch (c) {
>             // keywords
>         case 'b': return checkKeyword(1, 4, "reak", TOKEN_BREAK);
>         case 'c': {
>             int len = scanner.current - scanner.start;
>             if (len > 1) {
>                 switch (scanner.start[1]) {
>                     case 'a': return checkKeyword(2, 2, "se", TOKEN_CASE);
>                     case 'h': return checkKeyword(2, 2, "ar", TOKEN_CHAR);
>                     case 'o':
>                         if (len > 3 && scanner.start[2] == 'n') {
>                             switch (scanner.start[3]) {
>                                 case 's': return checkKeyword(4, 1, "t", TOKEN_CONST);
>                                 case 't': return checkKeyword(4, 4, "inue", TOKEN_CONTINUE);
>                             }
>                         }
>                 }
>             }
>             break;
>         }
>         case 'd': {
>             int len = scanner.current - scanner.start;
>             if (len > 1) {
>                 switch (scanner.start[1]) {
>                     case 'e': return checkKeyword(2, 5, "fault", TOKEN_DEFAULT);
>                     case 'o':
>                         if (len == 2) return TOKEN_DO;
>                         else return checkKeyword(2, 4, "uble", TOKEN_DOUBLE);
>                 }
>             }
>             break;
>         }
>         case 'e': {
>             int len = scanner.current - scanner.start;
>             if (len > 1) {
>                 switch (scanner.start[1]) {
>                     case 'l': return checkKeyword(2, 2, "se", TOKEN_ELSE);
>                     case 'n': return checkKeyword(2, 2, "um", TOKEN_ENUM);
>                 }
>             }
>             break;
>         }
>         case 'f': {
>             int len = scanner.current - scanner.start;
>             if (len > 1) {
>                 switch (scanner.start[1]) {
>                     case 'l': return checkKeyword(2, 3, "oat", TOKEN_FLOAT);
>                     case 'o': return checkKeyword(2, 1, "r", TOKEN_FOR);
>                 }
>             }
>             break;
>         }
>         case 'g': return checkKeyword(1, 3, "oto", TOKEN_GOTO);
>         case 'i': {
>             int len = scanner.current - scanner.start;
>             if (len > 1) {
>                 switch (scanner.start[1]) {
>                     case 'f': return checkKeyword(2, 0, "", TOKEN_IF);
>                     case 'n': return checkKeyword(2, 1, "t", TOKEN_INT);
>                 }
>             }
>             break;
>         }
>         case 'l': return checkKeyword(1, 3, "ong", TOKEN_LONG);
>         case 'r': return checkKeyword(1, 5, "eturn", TOKEN_RETURN);
>         case 's': {
>             int len = scanner.current - scanner.start;
>             if (len > 1) {
>                 switch (scanner.start[1]) {
>                     case 'h': return checkKeyword(2, 3, "ort", TOKEN_SHORT);
>                     case 'i':
>                         if (len > 2) {
>                             switch (scanner.start[2]) {
>                                 case 'g': return checkKeyword(3, 3, "ned", TOKEN_SIGNED);
>                                 case 'z': return checkKeyword(3, 3, "eof", TOKEN_SIZEOF);
>                             }
>                         }
>                         break;
>                     case 't': return checkKeyword(2, 4, "ruct", TOKEN_STRUCT);
>                     case 'w': return checkKeyword(2, 4, "itch", TOKEN_SWITCH);
>                 }
>             }
>             break;
>         }
>         case 't': return checkKeyword(1, 6, "ypedef", TOKEN_TYPEDEF);
>         case 'u': {
>             int len = scanner.current - scanner.start;
>             if (len > 2 && scanner.start[1] == 'n') {
>                 switch (scanner.start[2]) {
>                     case 'i': return checkKeyword(3, 2, "on", TOKEN_UNION);
>                     case 's': return checkKeyword(3, 5, "igned", TOKEN_UNSIGNED);
>                 }
>             }
>             break;
>         }
>         case 'v': return checkKeyword(1, 3, "oid", TOKEN_VOID);
>         case 'w': return checkKeyword(1, 4, "hile", TOKEN_WHILE);
>     }
> 
>     // 没有在上面switch中返回，那肯定不是关键字，而是标识符
>     return TOKEN_IDENTIFIER;
> }
> 
> // 当前Token的开头是下划线或字母判断它是不是标识符Token
> static Token identifier() {
>     // 判断curr指针当前正在处理的字符是不是 字母 下划线 数字
>     while (isAlpha(peek()) || isDigit(peek())) {
>         advance();  // 继续前进看下一个字符 直到碰到下一个字符不是字母 下划线 以及数字 结束Token
>     }
>     // 当while循环结束时，scanner.curr指针指向的是该Token字符串的下一个字符
>     // 这个函数的意思是: 只要读到字母或下划线开头的Token我们就进入标识符模式
>     // 然后一直找到此Token的末尾
>     // 但代码运行到这里还不确定Token是标识符还是关键字, 因为它可能是break, var, goto, max_val...
>     // 于是执行identifierType()函数，它是用来确定Token类型的
>     return makeToken(identifierType());
> }
> 
> static Token number() {
>     // 简单起见，我们将NUMBER的规则定义如下:
>     // 1. NUMBER可以包含数字和最多一个'.'号
>     // 2. '.'号前面要有数字
>     // 3. '.'号后面也要有数字
>     // 这些都是合法的NUMBER: 123, 3.14
>     // 这些都是不合法的NUMBER: 123., .14(虽然在C语言中合法)
>     // 这个过程要不断的前进跳过所有的数字,
>     // 比如数字123.456 最终要保证sc.start指向1,curr指向6后面第一个非数字字符
>     while (isDigit(peek())) advance();
> 
>     // 查找有无小数部分
>     if (peek() == '.' && isDigit(peekNext())) {
>         // 跳过小数点
>         advance();
>         while (isDigit(peek())) advance();
>     }
>     return makeToken(TOKEN_NUMBER);
> }
> 
> static Token string() {
>     // 字符串以"开头，以"结尾，而且不能跨行
>     // 为了简化工作量
>     // 如果下一个字符不是末尾也不是双引号，全部跳过(curr可以记录长度，不用担心)
>     while (!isAtEnd() && peek() != '"') {
>         if (peek() == '\n') {
>             return errorToken("Not support multi-line string.");
>         }
>         advance();
>     }
>     if (isAtEnd()) {
>         return errorToken("Unterminated string.");
>     }
>     advance();
>     return makeToken(TOKEN_STRING);
> }
> 
> // 进入字符处理模式
> static Token character() {
>     // 字符'开头，以'结尾，而且不能跨行，不支持转义字符，''中间必须只有一个字符
>     // 如果下一个字符不是末尾也不是单引号，全部跳过(curr可以记录长度，不用担心)
> 
>     // 1.判断当前curr指向的是不是空字符,如果是空字符,那就返回一个errToken
>     if (isAtEnd()) {
>         return errorToken("此字符不完整,缺少右单引号!");
>     }
>     // 2.让curr指针继续走,找到右单引号
>     while (!isAtEnd() && peek() != '\'') {
>         // 如果当前正在处理的字符既不是空字符,也不是右单引号,那就继续走
>         if (peek() == '\n') {
>             return errorToken("不支持多行字符!");
>         }
>         advance();
>     } // while循环结束时,要么处理到了空字符,要么处理到了右单引号
>     if (isAtEnd()) {
>         return errorToken("此字符不完整,缺少右单引号!");
>     }
>     // （重点）结束一个Token处理时，要保证curr指针移动向此Token的下一个位置！！！！
>     advance();
>     // 接下来要判断一下此字符是不是单个长度,单引号中出现多个字符是不允许的
>     int charLen = scanner.current - scanner.start - 2;
>     if (charLen == 1 || charLen == 0) {
>         return makeToken(TOKEN_CHARACTER);
>     }
>     // 需求: 现在单引号中间的字符序列长度超长了,于是要打印这个超长的序列
>     // 输出效果是: 非单字符Token: xxx(单引号中间的序列)
>     char *charStart = scanner.start + 1;
>     // 我们需要格式化的向目标字符数组中输出一个字符串
>     sprintf(message, "非单字符Token: %.*s", charLen, charStart);
>     return errorToken(message);
> }
> 
> // 处理无法识别的字符
> static Token errorTokenWithChar(char character) {
>     // 将无法识别的字符是什么输出
>     sprintf(message, "Unexpected character: %c", character);
>     return errorToken(message);
> }
> 
> // Scanner核心逻辑,用于返回制作好的Token对象
> Token scanToken() {
>     // 跳过前置空白字符和注释
>     skipWhitespace();
>     /*
> 		curr指针在处理完一个Token后,就会指向该Token的下一个字符位置
> 		而且由于skipWhitespace的存在会跳过前面的空白字符
> 		所以curr指针此时一定指向下一个Token的开始字符
> 		于是记录下一个Token的起始位置
> 		此时scanner.start就指向这一个要处理Token的首字符
> 	*/
>     scanner.start = scanner.current;
> 
>     // 如果当前正在处理的字符就是空字符,那就返回TOKEN_EOF,表示处理结束了
>     if (isAtEnd()) {
>         return makeToken(TOKEN_EOF);
>     }
> 
>     // curr指针现在指向当前Token的第二个字符,即curr指针前进了一位
>     // 但这个字符c仍然是该Token的第一个字符，因为advance函数会返回curr指针移动前指向的一个字符
>     char c = advance();
> 
>     // 如果Token的第一个字符是字母和下划线就进入标识符的处理模式
>     if (isAlpha(c)) {
>         return identifier();
>     }
>     // 如果Token的第一个字符是数字,那就进入数字的处理模式
>     if (isDigit(c)) return number();
> 
>     // 如果Token的第一个字符既不是数字也不是字母和下划线,那么就switch处理它
>     switch (c) {
>             // 第一部分: 处理单字符Token
>         case '(': return makeToken(TOKEN_LEFT_PAREN);
>         case ')': return makeToken(TOKEN_RIGHT_PAREN);
>         case '[': return makeToken(TOKEN_LEFT_BRACKET);
>         case ']': return makeToken(TOKEN_RIGHT_BRACKET);
>         case '{': return makeToken(TOKEN_LEFT_BRACE);
>         case '}': return makeToken(TOKEN_RIGHT_BRACE);
>         case ',': return makeToken(TOKEN_COMMA);
>         case '.': return makeToken(TOKEN_DOT);
>         case ';': return makeToken(TOKEN_SEMICOLON);
>         case '~': return makeToken(TOKEN_TILDE);
> 
>             // 可单可双字符的Token处理会稍微复杂一点,但不多
>             // 如果当前字符是+号
>         case '+':
>             // 如果Token的第二个字符也是+,那就生产++双字符Token返回
>             if (match('+')) {
>                 return makeToken(TOKEN_PLUS_PLUS);
>             }
>             // 如果Token的第二个字符是=,那就生产+=双字符Token返回
>             else if (match('=')) {
>                 return makeToken(TOKEN_PLUS_EQUAL);
>             }
>             // 如果上面都不是,说明就是单字符+ Token
>             else {
>                 return makeToken(TOKEN_PLUS);
>             }
>         case '-':
>             if (match('-')) {
>                 return makeToken(TOKEN_MINUS_MINUS);
>             }
>             else if (match('=')) {
>                 return makeToken(TOKEN_MINUS_EQUAL);
>             }
>             else if (match('>')) {
>                 return makeToken(TOKEN_MINUS_GREATER);
>             }
>             else {
>                 return makeToken(TOKEN_MINUS);
>             }
>         case '*':
>             return makeToken(match('=') ? TOKEN_STAR_EQUAL : TOKEN_STAR);
>         case '/':
>             return makeToken(match('=') ? TOKEN_SLASH_EQUAL : TOKEN_SLASH);
>         case '%':
>             return makeToken(match('=') ? TOKEN_PERCENT_EQUAL : TOKEN_PERCENT);
>         case '&':
>             if (match('=')) {
>                 return makeToken(TOKEN_AMPER_EQUAL);
>             }
>             else if (match('&')) {
>                 return makeToken(TOKEN_AMPER_AMPER);
>             }
>             else {
>                 return makeToken(TOKEN_AMPER);
>             }
>         case '|':
>             if (match('=')) {
>                 return makeToken(TOKEN_PIPE_EQUAL);
>             }
>             else if (match('|')) {
>                 return makeToken(TOKEN_PIPE_PIPE);
>             }
>             else {
>                 return makeToken(TOKEN_PIPE);
>             }
>         case '^':
>             return makeToken(match('=') ? TOKEN_HAT_EQUAL : TOKEN_HAT);
>         case '=':
>             return makeToken(match('=') ? TOKEN_EQUAL_EQUAL : TOKEN_EQUAL);
>         case '!':
>             return makeToken(match('=') ? TOKEN_BANG_EQUAL : TOKEN_BANG);
>         case '<':
>             if (match('=')) {
>                 return makeToken(TOKEN_LESS_EQUAL);
>             }
>             else if (match('<')) {
>                 return makeToken(TOKEN_LESS_LESS);
>             }
>             else {
>                 return makeToken(TOKEN_LESS);
>             }
>         case '>':
>             if (match('=')) {
>                 return makeToken(TOKEN_GREATER_EQUAL);
>             }
>             else if (match('>')) {
>                 return makeToken(TOKEN_GREATER_GREATER);
>             }
>             else {
>                 return makeToken(TOKEN_GREATER);
>             }
>             // 多字符Token处理,上面已经处理过标识符和数字了 
>         case '"': return string(); // 如果Token的第一个字符是双引号,那就进入字符串处理模式
>         case '\'': return character();	// 如果Token的第一个字符是单引号,那就进入字符处理模式
>     }
>     // 如果读到的字符不在上面的所有之列,那就无法识别,于是制造一个errorToken返回
>     // 比如代码中的#(预处理阶段就没了) $(C语言不用该字符) 注释中的中文
>     return errorTokenWithChar(c);
> }
> ````

## trie树

> _~Gn!~_
>
> trie树(字典树)，是一种用于存储和查找字符串的树形数据结构。它的主要特点是：
>
> 1. **根节点通常代表空字符串。**
> 2. **每个节点代表一个字符串（通常是字符）的前缀。**
> 3. **Trie树中的每个节点包含多个子节点，每个子节点代表在当前字符串后追加一个字符后形成的新字符串。**
> 4. **每一个节点都可以包含一个标记来表示一个完成的单词。**
>
> 比如我们用来查找关键字的trie树就如下图所示：
>
> ![关键字Tire树-图](https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202401170818429.png?align=center#padding)
>
> trie树的优点有：
>
> 1. 基于共享前缀节点的方式节省内存空间
> 2. 基于字典顺序存储字符串，可以直接进行有序遍历。再加上前缀式的匹配模式，使得它查找字符串的效率很高。尤其是在应对单词，这种字典顺序排列，共享前缀多的场景中，效率非常高。trie树最常见的应用场景就是单词拼写检查，单词自动补全...
> 3. 从根节点开始进行前缀式的匹配，这和我们词法分析器处理Token的方式是一致的
>
> trie树很好，但你也不要害怕，传统的trie树需要新建结点，一点点的构建一棵trie树，但我们这里不需要。
>
> 由于关键字属于编程语言中很少改动的一个语法，比如C语言十年也就加了不到5个关键字，C++/Java也不是每年都会更新关键字。
>
> 关键字总体属于一个比较静态的数据。
>
> 于是我们可以使用switch...if组建一棵逻辑上的trie树，由于C语言switch选择硬编码(编译时期确定)的特性，所以这种实现往往比传统结点trie树空间占用少，效率更高。
>
> 当然这种实现它也不是没有缺点的：
>
> 1. 代码丑陋，switch套switch套if...else
> 2. 可读性很差，可维护性很差，编写的过程容易出错
>
> 但好在，对于一门语言来说，匹配关键字的这段代码很少被修改，只要写好了就很少有改动的机会，那么这些缺点换来了高效率，就是可以接受的。
>
> 下面我们给大家举一个例子：
>
> ```` c
> // 用于检查当前扫描的Token的类型是不是type 如果是就返回type
> static TokenType checkKeyword(int start, int length, const char *rest, TokenType type) {
> 	/*
> 		start: 待检查序列的起始字符下标
> 			比如要检查关键字break，那么在case b的前提下，需要传入reak来进行检查
> 			这里start就等于1，scanner.start[1]
> 		length: 待检查序列的长度，如果检查的是break，就是检查剩余的reak
> 			需要传入4
> 		rest指针，待检查的剩余序列字符串，这里直接传入一个字面值字符串就行了
> 			比如检查break，传入"reak"就好了
> 		type：你要检查的关键字Token的类型，比如检查break，那就传入Token_BREAK
> 
> 		检查从start位置开始，长度为length的字符串是否与给定的rest字符串相匹配
> 		先判断长度是否一致 再判断内容
> 	*/
> 	if (scanner.current - scanner.start == start + length &&
> 		/*
> 					int memcmp(const void *s1, const void *s2, size_t n);
> 					这里的参数分别是：
> 
> 					s1：指向第一块内存区域的指针。
> 					s2：指向第二块内存区域的指针。
> 					n：要比较的字节数。
> 					memcmp 函数会逐字节比较 s1 和 s2 指向的内存区域，直到有不相等的字节或比较了 n 个字节为止。
> 					如果两个内存区域完全相同，
> 					则 memcmp 返回 0；如果第一个不同的字节在 s1 中的值小于 s2 中对应的值，返回负数；
> 					反之，返回正数。
> 		*/
> 		memcmp(scanner.start + start, rest, length) == 0) {
> 		return type;
> 	}
> 	return TOKEN_IDENTIFIER;
> }
> 
> static TokenType identifierType() {
> 	// 确定identifier类型主要有两种方式：
> 	// 1. 将所有的关键字放入哈希表中，然后查表确认 
> 	// Key-Value 就是"关键字-TokenType" 可以做 但存在额外内存占用且效率不如下一个方式好
> 	// 2. 将所有的关键字放入Trie树(读踹，字典查找树)中，然后查表确认
> 	// Trie树的方式不管是空间上还是时间上都优于哈希表的方式
> 	char c = scanner.start[0];
> 	// 用switch...switch...if组合构建逻辑上的trie树
> 	switch (c) {
> 		// keywords
> 	case 'b': return checkKeyword(1, 4, "reak", TOKEN_BREAK);
> 	case 'c': {
> 		int len = scanner.current - scanner.start;
> 		if (len > 1) {
> 			switch (scanner.start[1]) {
> 			case 'a': return checkKeyword(2, 2, "se", TOKEN_CASE);
> 			case 'h': return checkKeyword(2, 2, "ar", TOKEN_CHAR);
> 			case 'o':
> 				if (len > 3 && scanner.start[2] == 'n') {
> 					switch (scanner.start[3]) {
> 					case 's': return checkKeyword(4, 1, "t", TOKEN_CONST);
> 					case 't': return checkKeyword(4, 4, "inue", TOKEN_CONTINUE);
> 					}
> 				}
> 			}
> 		}
> 		break;
> 	}
> 	case 'd': {
> 		int len = scanner.current - scanner.start;
> 		if (len > 1) {
> 			switch (scanner.start[1]) {
> 			case 'e': return checkKeyword(2, 5, "fault", TOKEN_DEFAULT);
> 			case 'o':
> 				if (len == 2) return TOKEN_DO;
> 				else return checkKeyword(2, 4, "uble", TOKEN_DOUBLE);
> 			}
> 		}
> 		break;
> 	}
> 	case 'e': {
> 		int len = scanner.current - scanner.start;
> 		if (len > 1) {
> 			switch (scanner.start[1]) {
> 			case 'l': return checkKeyword(2, 2, "se", TOKEN_ELSE);
> 			case 'n': return checkKeyword(2, 2, "um", TOKEN_ENUM);
> 			}
> 		}
> 		break;
> 	}
> 	case 'f': {
> 		int len = scanner.current - scanner.start;
> 		if (len > 1) {
> 			switch (scanner.start[1]) {
> 			case 'l': return checkKeyword(2, 3, "oat", TOKEN_FLOAT);
> 			case 'o': return checkKeyword(2, 1, "r", TOKEN_FOR);
> 			}
> 		}
> 		break;
> 	}
> 	case 'g': return checkKeyword(1, 3, "oto", TOKEN_GOTO);
> 	case 'i': {
> 		int len = scanner.current - scanner.start;
> 		if (len > 1) {
> 			switch (scanner.start[1]) {
> 			case 'f': return checkKeyword(2, 0, "", TOKEN_IF);
> 			case 'n': return checkKeyword(2, 1, "t", TOKEN_INT);
> 			}
> 		}
> 		break;
> 	}
> 	case 'l': return checkKeyword(1, 3, "ong", TOKEN_LONG);
> 	case 'r': return checkKeyword(1, 5, "eturn", TOKEN_RETURN);
> 	case 's': {
> 		int len = scanner.current - scanner.start;
> 		if (len > 1) {
> 			switch (scanner.start[1]) {
> 			case 'h': return checkKeyword(2, 3, "ort", TOKEN_SHORT);
> 			case 'i':
> 				if (len > 2) {
> 					switch (scanner.start[2]) {
> 					case 'g': return checkKeyword(3, 3, "ned", TOKEN_SIGNED);
> 					case 'z': return checkKeyword(3, 3, "eof", TOKEN_SIZEOF);
> 					}
> 				}
> 				break;
> 			case 't': return checkKeyword(2, 4, "ruct", TOKEN_STRUCT);
> 			case 'w': return checkKeyword(2, 4, "itch", TOKEN_SWITCH);
> 			}
> 		}
> 		break;
> 	}
> 	case 't': return checkKeyword(1, 6, "ypedef", TOKEN_TYPEDEF);
> 	case 'u': {
> 		int len = scanner.current - scanner.start;
> 		if (len > 2 && scanner.start[1] == 'n') {
> 			switch (scanner.start[2]) {
> 			case 'i': return checkKeyword(3, 2, "on", TOKEN_UNION);
> 			case 's': return checkKeyword(3, 5, "igned", TOKEN_UNSIGNED);
> 			}
> 		}
> 		break;
> 	}
> 	case 'v': return checkKeyword(1, 3, "oid", TOKEN_VOID);
> 	case 'w': return checkKeyword(1, 4, "hile", TOKEN_WHILE);
> 	}
> 
> 	// 没有在上面switch中返回，那肯定不是关键字，而是标识符
> 	return TOKEN_IDENTIFIER;
> }
> ````
>
> 以上。



